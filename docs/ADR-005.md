# ADR-005: REST API Design

## Status

Implemented

## Context

The Mattilda Challenge system requires a REST API to expose school billing operations. The API must support CRUD operations for schools, students, invoices, and payments, as well as provide aggregated financial information through account statement endpoints.

**Scope of This ADR:**

This ADR defines the **REST boundary and HTTP-facing conventions**: endpoint structure, DTO design, mapper pattern, OpenAPI documentation, and error handling translation. Domain invariants (monetary correctness, immutability, time injection) and persistence guarantees (transactions, UUID mapping) are defined in prior ADRs and referenced here.

**Out of Scope:**
- Domain model design → See [ADR-002](ADR-002-domain-model.md)
- Decimal arithmetic internals → See [ADR-002](ADR-002-domain-model.md)
- Time provider implementation → See [ADR-003](ADR-003-time-provider.md)
- Database persistence strategy → See [ADR-004](ADR-004-postgresql-persistence.md)
- Testing strategy → See [CONTRIBUTING.md](../../CONTRIBUTING.md)

This ADR builds upon the architectural decisions made in previous ADRs:

- **[ADR-001](ADR-001-project-initialization.md)**: Clean Architecture, immutability, ABC ports
- **[ADR-002](ADR-002-domain-model.md)**: Domain entities, UUID identifiers, Decimal arithmetic, LateFeePolicy
- **[ADR-003](ADR-003-time-provider.md)**: Time injection, UTC-only policy
- **[ADR-004](ADR-004-postgresql-persistence.md)**: PostgreSQL persistence, Unit of Work, Data Mapper pattern

### Requirements (from Challenge PDF)

The API must support:

**Core CRUD Operations:**
- Schools (Colegios)
- Students (Estudiantes) 
- Invoices (Facturas)
- Payments (Pagos)

**Business Questions to Answer:**
- ¿Cuánto le debe un estudiante a un colegio? (How much does a student owe?)
- ¿Cuánto le deben todos los estudiantes a un colegio? (How much do all students owe?)
- ¿Cuántos alumnos tiene un colegio? (How many students does a school have?)
- ¿Cuál es el estado de cuenta de un colegio o estudiante? (What is the account statement?)

**Technical Requirements:**
- Language: Python
- Framework: FastAPI (required)
- Database: PostgreSQL (required)
- Automatic OpenAPI/Swagger documentation
- Dockerized with Docker Compose

**Evaluation Criteria:**
- Table and ORM model design
- Data validation and business rules
- Documentation (README + docstrings)
- Tests (unit and integration)
- Code readability, structure, and complexity

---

## Goals

1. **Thin REST layer**: Controllers orchestrate (parse → execute → map → return), no business logic
2. **Mapper pattern**: Class-based translation between DTOs and domain models
3. **Decimal boundary enforcement**: All monetary values as strings in DTOs, converted to Decimal at boundary
4. **Rich OpenAPI documentation**: Auto-generated with examples, descriptions, and error responses
5. **Clean error handling**: Global exception handlers, domain exceptions mapped to HTTP status codes
6. **URL versioning**: Explicit `/api/v1` prefix for all endpoints
7. **Maintainability**: Patterns that scale as endpoints are added

---

## Decision

### 1. Architecture: Mapper Pattern

We use **class-based mappers** (evolution of assembler pattern) to translate between REST DTOs and domain models.

**Why Mappers:**
- ✅ Groups related conversions together (easier to discover)
- ✅ Controller stays simple and readable
- ✅ Easy to test all mappings in one test file
- ✅ Can share helper methods if needed
- ✅ Scales well as we add more endpoints

**Why not DTO methods:**
- ✅ Respects Clean Architecture (outer layer shouldn't make inner layer aware of it)
- ✅ Domain entities stay pure, unaware of REST concerns
- ✅ Easier to test mappings independently

**Mapper Responsibilities:**
- Protocol adapter between REST types and domain types
- Handles `str → Decimal` conversion at the boundary
- Handles `UUID str → value object` conversion
- Handles `Decimal → str` and `UUID → str` for responses
- Handles `datetime → ISO 8601 string` for responses
- No business logic, just translation

**Critical Constraint:**
Mappers are **pure, deterministic functions** — they perform transformations only and must NOT:
- Access repositories or services
- Query databases
- Call external APIs
- Access any mutable state beyond their parameters
- Perform I/O operations

The only external dependency allowed is the injected `now` parameter for timestamp conversions.

---

### 2. Folder Structure

```
src/mattilda_challenge/
  entrypoints/
    http/
      app.py                              # FastAPI app + global exception handlers
      dependencies.py                     # DI factory functions
      routes/
        __init__.py
        schools.py                        # School CRUD + account statement
        students.py                       # Student CRUD + account statement
        invoices.py                       # Invoice CRUD
        payments.py                       # Payment operations
        health.py                         # Health check endpoint
      dtos/
        __init__.py
        school_dtos.py                    # SchoolCreateRequestDTO, SchoolResponseDTO, etc.
        student_dtos.py                   # StudentCreateRequestDTO, StudentResponseDTO, etc.
        invoice_dtos.py                   # InvoiceCreateRequestDTO, InvoiceResponseDTO, etc.
        payment_dtos.py                   # PaymentCreateRequestDTO, PaymentResponseDTO, etc.
        account_statement_dtos.py         # StudentAccountStatementDTO, SchoolAccountStatementDTO
      mappers/
        __init__.py
        school_mapper.py                  # SchoolMapper class
        student_mapper.py                 # StudentMapper class
        invoice_mapper.py                 # InvoiceMapper class
        payment_mapper.py                 # PaymentMapper class
        account_statement_mapper.py       # AccountStatementMapper class
```

---

## 3. Core API Endpoints

### 3.1 Endpoint Inventory

All endpoints use `/api/v1` prefix for explicit versioning.

#### Schools

| Method | Endpoint | Description | Status Code |
|--------|----------|-------------|-------------|
| GET | `/api/v1/schools` | List schools (paginated) | 200 |
| POST | `/api/v1/schools` | Create school | 201 |
| GET | `/api/v1/schools/{id}` | Get school details | 200, 404 |
| PUT | `/api/v1/schools/{id}` | Update school | 200, 404 |
| DELETE | `/api/v1/schools/{id}` | Delete school | 204, 404 |
| GET | `/api/v1/schools/{id}/account-statement` | School account statement (cached) | 200, 404 |

#### Students

| Method | Endpoint | Description | Status Code |
|--------|----------|-------------|-------------|
| GET | `/api/v1/students` | List students (paginated) | 200 |
| POST | `/api/v1/students` | Create student | 201 |
| GET | `/api/v1/students/{id}` | Get student details | 200, 404 |
| PUT | `/api/v1/students/{id}` | Update student | 200, 404 |
| DELETE | `/api/v1/students/{id}` | Delete student | 204, 404 |
| GET | `/api/v1/students/{id}/account-statement` | Student account statement (cached) | 200, 404 |

#### Invoices

| Method | Endpoint | Description | Status Code |
|--------|----------|-------------|-------------|
| GET | `/api/v1/invoices` | List invoices (paginated) | 200 |
| POST | `/api/v1/invoices` | Create invoice | 201 |
| GET | `/api/v1/invoices/{id}` | Get invoice details | 200, 404 |
| PUT | `/api/v1/invoices/{id}` | Update invoice | 200, 404 |
| DELETE | `/api/v1/invoices/{id}` | Delete invoice | 204, 404 |
| POST | `/api/v1/invoices/{id}/cancel` | Cancel invoice | 200, 400, 404 |

#### Payments

| Method | Endpoint | Description | Status Code |
|--------|----------|-------------|-------------|
| GET | `/api/v1/payments` | List payments (paginated) | 200 |
| POST | `/api/v1/payments` | Record payment against invoice | 201 |
| GET | `/api/v1/payments/{id}` | Get payment details | 200, 404 |

#### Health & Monitoring

| Method | Endpoint | Description | Status Code |
|--------|----------|-------------|-------------|
| GET | `/health` | Health check | 200 |
| GET | `/docs` | Swagger UI documentation | 200 |
| GET | `/redoc` | ReDoc documentation | 200 |
| GET | `/openapi.json` | OpenAPI schema | 200 |

---

### 3.2 Endpoint Details

#### 3.2.1 Create Invoice

**Endpoint:** `POST /api/v1/invoices`

**Request DTO:**
```python
class InvoiceCreateRequestDTO(BaseModel):
    """Request to create a new invoice for a student."""
    
    student_id: str = Field(
        description="Student UUID who will be invoiced",
        examples=["550e8400-e29b-41d4-a716-446655440000"]
    )
    
    amount: str = Field(
        description="Invoice amount in MXN (decimal as string, always 2 decimal places)",
        examples=["1500.00", "2350.50", "10000.00"],
        pattern=r"^\d+\.\d{2}$"
    )
    
    due_date: str = Field(
        description="Payment due date (ISO 8601 format, UTC)",
        examples=["2024-02-15T00:00:00Z", "2024-03-01T23:59:59Z"]
    )
    
    description: str = Field(
        description="Invoice description/concept",
        examples=["January 2024 Tuition", "Lab Materials Fee", "School Uniform"]
    )
    
    late_fee_policy_monthly_rate: str = Field(
        description="Monthly late fee rate as decimal (e.g., '0.05' for 5% monthly)",
        examples=["0.05", "0.03", "0.00"],
        pattern=r"^[01]\.\d{2,4}$"
    )
    
    class Config:
        json_schema_extra = {
            "examples": [
                {
                    "student_id": "550e8400-e29b-41d4-a716-446655440000",
                    "amount": "1500.00",
                    "due_date": "2024-02-15T00:00:00Z",
                    "description": "February 2024 Tuition",
                    "late_fee_policy_monthly_rate": "0.05"
                }
            ]
        }
```

**Response DTO:**
```python
class InvoiceResponseDTO(BaseModel):
    """Invoice entity response."""
    
    id: str = Field(
        description="Unique invoice identifier (UUID)",
        examples=["7c9e6679-7425-40de-944b-e07fc1f90ae7"]
    )
    
    student_id: str = Field(
        description="Student UUID",
        examples=["550e8400-e29b-41d4-a716-446655440000"]
    )
    
    invoice_number: str = Field(
        description="Human-readable invoice number (decorative, not unique)",
        examples=["INV-2024-000042"]
    )
    
    amount: str = Field(
        description="Invoice amount in MXN",
        examples=["1500.00"]
    )
    
    due_date: str = Field(
        description="Payment due date (ISO 8601 UTC)",
        examples=["2024-02-15T00:00:00Z"]
    )
    
    description: str = Field(
        description="Invoice description",
        examples=["February 2024 Tuition"]
    )
    
    late_fee_policy_monthly_rate: str = Field(
        description="Monthly late fee rate",
        examples=["0.05"]
    )
    
    status: str = Field(
        description="Invoice payment status",
        examples=["pending", "partially_paid", "paid", "cancelled"]
    )
    
    created_at: str = Field(
        description="Creation timestamp (ISO 8601 UTC)",
        examples=["2024-01-15T10:30:00Z"]
    )
    
    updated_at: str = Field(
        description="Last update timestamp (ISO 8601 UTC)",
        examples=["2024-01-15T10:30:00Z"]
    )
    
    # Computed fields (not stored)
    is_overdue: bool = Field(
        description="Whether invoice is overdue (computed from due_date and current time)"
    )
    
    late_fee: str = Field(
        description="Current late fee amount (computed, may be '0.00')",
        examples=["37.50", "0.00"]
    )
    
    class Config:
        json_schema_extra = {
            "example": {
                "id": "7c9e6679-7425-40de-944b-e07fc1f90ae7",
                "student_id": "550e8400-e29b-41d4-a716-446655440000",
                "invoice_number": "INV-2024-000042",
                "amount": "1500.00",
                "due_date": "2024-02-15T00:00:00Z",
                "description": "February 2024 Tuition",
                "late_fee_policy_monthly_rate": "0.05",
                "status": "pending",
                "created_at": "2024-01-15T10:30:00Z",
                "updated_at": "2024-01-15T10:30:00Z",
                "is_overdue": False,
                "late_fee": "0.00"
            }
        }
```

**Route Implementation:**
```python
@router.post(
    "/invoices",
    response_model=InvoiceResponseDTO,
    status_code=status.HTTP_201_CREATED,
    summary="Create new invoice",
    description="""
    Create a new invoice for a student.
    
    ## Business Rules
    - Student must exist and be ACTIVE
    - Amount must be positive
    - Due date must be in the future or today
    - Late fee rate between 0% and 100% (0.00 to 1.00)
    
    ## Late Fee Calculation
    - Fees calculated based on ORIGINAL invoice amount (not remaining balance)
    - Monthly rate prorated daily (30-day month assumption)
    - Fees begin accruing immediately after due date (no grace period)
    - Formula: `original_amount × monthly_rate × (days_overdue / 30)`
    
    ## Invoice Number
    
    **Invariants:**
    - Human-readable format: INV-YYYY-NNNNNN (e.g., INV-2024-000042)
    - Decorative only — **UUID is the only authoritative identifier**
    - Generated at creation and never changes
    - Never used for lookups (use UUID instead)
    - Not guaranteed unique under high concurrency (acceptable trade-off)
    
    **Production Note:** For true uniqueness, replace with database-backed sequence per school/year.
    For this challenge, timestamp-based suffix is sufficient and demonstrates concurrency awareness.
    
    ## Examples
    
    Create tuition invoice:
    ```bash
    curl -X POST http://localhost:8000/api/v1/invoices \
      -H "Content-Type: application/json" \
      -d '{
        "student_id": "550e8400-e29b-41d4-a716-446655440000",
        "amount": "1500.00",
        "due_date": "2024-02-15T00:00:00Z",
        "description": "February 2024 Tuition",
        "late_fee_policy_monthly_rate": "0.05"
      }'
    ```
    
    Create fee with no late charges:
    ```bash
    curl -X POST http://localhost:8000/api/v1/invoices \
      -H "Content-Type: application/json" \
      -d '{
        "student_id": "550e8400-e29b-41d4-a716-446655440000",
        "amount": "250.00",
        "due_date": "2024-02-01T00:00:00Z",
        "description": "Lab Materials Fee",
        "late_fee_policy_monthly_rate": "0.00"
      }'
    ```
    """,
    responses={
        201: {
            "description": "Invoice created successfully",
            "content": {
                "application/json": {
                    "example": {
                        "id": "7c9e6679-7425-40de-944b-e07fc1f90ae7",
                        "student_id": "550e8400-e29b-41d4-a716-446655440000",
                        "invoice_number": "INV-2024-000042",
                        "amount": "1500.00",
                        "due_date": "2024-02-15T00:00:00Z",
                        "description": "February 2024 Tuition",
                        "late_fee_policy_monthly_rate": "0.05",
                        "status": "pending",
                        "created_at": "2024-01-15T10:30:00Z",
                        "updated_at": "2024-01-15T10:30:00Z",
                        "is_overdue": False,
                        "late_fee": "0.00"
                    }
                }
            }
        },
        404: {
            "description": "Student not found",
            "content": {
                "application/json": {
                    "example": {
                        "detail": "Student 550e8400-e29b-41d4-a716-446655440000 not found"
                    }
                }
            }
        },
        422: {
            "description": "Validation error",
            "content": {
                "application/json": {
                    "examples": {
                        "invalid_amount": {
                            "summary": "Invalid amount format",
                            "value": {
                                "detail": [
                                    {
                                        "loc": ["body", "amount"],
                                        "msg": "string does not match regex",
                                        "type": "value_error.str.regex"
                                    }
                                ]
                            }
                        },
                        "invalid_date": {
                            "summary": "Invalid date format",
                            "value": {
                                "detail": [
                                    {
                                        "loc": ["body", "due_date"],
                                        "msg": "invalid datetime format",
                                        "type": "value_error.datetime"
                                    }
                                ]
                            }
                        },
                        "negative_amount": {
                            "summary": "Domain validation error",
                            "value": {
                                "detail": "Invoice amount must be positive, got Decimal('-100.00')"
                            }
                        }
                    }
                }
            }
        }
    },
    tags=["Invoices"]
)
async def create_invoice(
    request: InvoiceCreateRequestDTO,
    session: AsyncSession = Depends(get_session),
    time_provider: TimeProvider = Depends(get_time_provider),
) -> InvoiceResponseDTO:
    """
    Create invoice endpoint handler.
    
    Controller pattern: parse → map → execute → map → return
    No business logic in controller.
    """
    async with UnitOfWork(session) as uow:
        # Map DTO to domain request
        domain_request = InvoiceMapper.to_create_request(
            request, 
            time_provider.now()
        )
        
        # Execute use case
        use_case = CreateInvoiceUseCase()
        invoice = await use_case.execute(uow, domain_request)
        
        # Map domain entity to response DTO
        return InvoiceMapper.to_response(invoice, time_provider.now())
```

**Mapper Implementation:**
```python
# entrypoints/http/mappers/invoice_mapper.py

class InvoiceMapper:
    """Maps between Invoice DTOs and domain models."""
    
    @staticmethod
    def to_create_request(
        dto: InvoiceCreateRequestDTO, 
        now: datetime
    ) -> CreateInvoiceRequest:
        """
        Convert REST DTO to domain request.
        
        Handles:
        - str → Decimal (amount, late_fee_rate)
        - str → UUID → StudentId value object
        - str → datetime (ISO 8601 → UTC datetime)
        - Time injection (now parameter)
        """
        return CreateInvoiceRequest(
            student_id=StudentId.from_string(dto.student_id),
            amount=Decimal(dto.amount),
            due_date=parse_iso8601_utc(dto.due_date),
            description=dto.description,
            late_fee_policy=LateFeePolicy(
                monthly_rate=Decimal(dto.late_fee_policy_monthly_rate)
            ),
            now=now
        )
    
    @staticmethod
    def to_response(invoice: Invoice, now: datetime) -> InvoiceResponseDTO:
        """
        Convert domain entity to REST response DTO.
        
        Handles:
        - UUID value objects → str
        - Decimal → str (monetary values)
        - datetime → str (ISO 8601 format)
        - Computed fields (is_overdue, late_fee)
        """
        return InvoiceResponseDTO(
            id=str(invoice.id),
            student_id=str(invoice.student_id),
            invoice_number=invoice.invoice_number,
            amount=str(invoice.amount),
            due_date=invoice.due_date.isoformat(),
            description=invoice.description,
            late_fee_policy_monthly_rate=str(invoice.late_fee_policy.monthly_rate),
            status=invoice.status.value,
            created_at=invoice.created_at.isoformat(),
            updated_at=invoice.updated_at.isoformat(),
            # Computed fields
            is_overdue=invoice.is_overdue(now),
            late_fee=str(invoice.calculate_late_fee(now))
        )
```

#### 3.2.2 Record Payment

**Endpoint:** `POST /api/v1/payments`

**Request DTO:**
```python
class PaymentCreateRequestDTO(BaseModel):
    """Request to record a payment against an invoice."""
    
    invoice_id: str = Field(
        description="Invoice UUID to apply payment to",
        examples=["7c9e6679-7425-40de-944b-e07fc1f90ae7"]
    )
    
    amount: str = Field(
        description="Payment amount in MXN (decimal as string)",
        examples=["500.00", "1500.00"],
        pattern=r"^\d+\.\d{2}$"
    )
    
    payment_date: str = Field(
        description="Date when payment was made (ISO 8601 UTC, may be in past)",
        examples=["2024-01-20T14:30:00Z"]
    )
    
    payment_method: str = Field(
        description="How payment was made",
        examples=["cash", "bank_transfer", "credit_card", "debit_card", "check"]
    )
    
    reference_number: str | None = Field(
        None,
        description="External reference number (e.g., transaction ID)",
        examples=["TXN-20240120-001", "CHK-12345", None]
    )
    
    class Config:
        json_schema_extra = {
            "examples": [
                {
                    "invoice_id": "7c9e6679-7425-40de-944b-e07fc1f90ae7",
                    "amount": "500.00",
                    "payment_date": "2024-01-20T14:30:00Z",
                    "payment_method": "bank_transfer",
                    "reference_number": "TXN-20240120-001"
                },
                {
                    "invoice_id": "7c9e6679-7425-40de-944b-e07fc1f90ae7",
                    "amount": "1500.00",
                    "payment_date": "2024-01-20T14:30:00Z",
                    "payment_method": "cash",
                    "reference_number": None
                }
            ]
        }
```

**Response DTO:**
```python
class PaymentResponseDTO(BaseModel):
    """Payment entity response."""
    
    id: str = Field(
        description="Unique payment identifier (UUID)",
        examples=["9f8e7d6c-5b4a-3c2d-1e0f-9a8b7c6d5e4f"]
    )
    
    invoice_id: str = Field(
        description="Invoice UUID",
        examples=["7c9e6679-7425-40de-944b-e07fc1f90ae7"]
    )
    
    amount: str = Field(
        description="Payment amount in MXN",
        examples=["500.00"]
    )
    
    payment_date: str = Field(
        description="When payment was made (ISO 8601 UTC)",
        examples=["2024-01-20T14:30:00Z"]
    )
    
    payment_method: str = Field(
        description="Payment method",
        examples=["bank_transfer"]
    )
    
    reference_number: str | None = Field(
        description="External reference number",
        examples=["TXN-20240120-001", None]
    )
    
    created_at: str = Field(
        description="When payment was recorded in system (ISO 8601 UTC)",
        examples=["2024-01-20T14:35:00Z"]
    )
    
    class Config:
        json_schema_extra = {
            "example": {
                "id": "9f8e7d6c-5b4a-3c2d-1e0f-9a8b7c6d5e4f",
                "invoice_id": "7c9e6679-7425-40de-944b-e07fc1f90ae7",
                "amount": "500.00",
                "payment_date": "2024-01-20T14:30:00Z",
                "payment_method": "bank_transfer",
                "reference_number": "TXN-20240120-001",
                "created_at": "2024-01-20T14:35:00Z"
            }
        }
```

**Route Implementation:**
```python
@router.post(
    "/payments",
    response_model=PaymentResponseDTO,
    status_code=status.HTTP_201_CREATED,
    summary="Record payment against invoice",
    description="""
    Record a payment against an invoice. Supports partial payments.
    
    ## Business Rules
    - Invoice must exist and not be CANCELLED
    - Payment amount must be positive
    - Payment amount cannot exceed invoice balance due
    - Invoice status updated atomically:
      - PENDING → PARTIALLY_PAID (first partial payment)
      - PENDING → PAID (full payment)
      - PARTIALLY_PAID → PAID (final payment)
    
    ## Partial Payments
    - Multiple payments can be applied to same invoice
    - Each payment is immutable (append-only audit trail)
    - Balance due = invoice.amount - SUM(payments.amount)
    
    ## Atomicity
    - Payment record + invoice status update in single transaction
    - Uses row-level locking to prevent race conditions
    - Either both succeed or both rollback
    
    ## Examples
    
    First partial payment:
    ```bash
    curl -X POST http://localhost:8000/api/v1/payments \
      -H "Content-Type: application/json" \
      -d '{
        "invoice_id": "7c9e6679-7425-40de-944b-e07fc1f90ae7",
        "amount": "500.00",
        "payment_date": "2024-01-20T14:30:00Z",
        "payment_method": "bank_transfer",
        "reference_number": "TXN-001"
      }'
    ```
    
    Final payment (completes invoice):
    ```bash
    curl -X POST http://localhost:8000/api/v1/payments \
      -H "Content-Type: application/json" \
      -d '{
        "invoice_id": "7c9e6679-7425-40de-944b-e07fc1f90ae7",
        "amount": "1000.00",
        "payment_date": "2024-02-01T10:00:00Z",
        "payment_method": "cash",
        "reference_number": null
      }'
    ```
    """,
    responses={
        201: {"description": "Payment recorded successfully"},
        400: {
            "description": "Business rule violation",
            "content": {
                "application/json": {
                    "examples": {
                        "cancelled_invoice": {
                            "summary": "Cannot pay cancelled invoice",
                            "value": {
                                "detail": "Cannot record payment for cancelled invoice"
                            }
                        }
                    }
                }
            }
        },
        404: {
            "description": "Invoice not found",
            "content": {
                "application/json": {
                    "example": {
                        "detail": "Invoice 7c9e6679-7425-40de-944b-e07fc1f90ae7 not found"
                    }
                }
            }
        },
        422: {
            "description": "Validation error",
            "content": {
                "application/json": {
                    "examples": {
                        "exceeds_balance": {
                            "summary": "Payment exceeds balance due",
                            "value": {
                                "detail": "Payment 1500.00 exceeds balance due 1000.00"
                            }
                        },
                        "negative_amount": {
                            "summary": "Negative payment amount",
                            "value": {
                                "detail": "Payment amount must be positive, got Decimal('-100.00')"
                            }
                        }
                    }
                }
            }
        }
    },
    tags=["Payments"]
)
async def record_payment(
    request: PaymentCreateRequestDTO,
    session: AsyncSession = Depends(get_session),
    time_provider: TimeProvider = Depends(get_time_provider),
) -> PaymentResponseDTO:
    """Record payment endpoint handler."""
    async with UnitOfWork(session) as uow:
        domain_request = PaymentMapper.to_create_request(
            request,
            time_provider.now()
        )
        
        use_case = RecordPaymentUseCase()
        payment = await use_case.execute(uow, domain_request)
        
        return PaymentMapper.to_response(payment)
```

#### 3.2.3 Student Account Statement

**Endpoint:** `GET /api/v1/students/{id}/account-statement`

**Response DTO:**
```python
class StudentAccountStatementDTO(BaseModel):
    """Student account statement (aggregated financial summary)."""
    
    student_id: str = Field(
        description="Student UUID",
        examples=["550e8400-e29b-41d4-a716-446655440000"]
    )
    
    student_name: str = Field(
        description="Student full name",
        examples=["Juan Pérez García"]
    )
    
    school_name: str = Field(
        description="School name",
        examples=["Colegio ABC"]
    )
    
    total_invoiced: str = Field(
        description="Total amount invoiced to student (all time)",
        examples=["4500.00"]
    )
    
    total_paid: str = Field(
        description="Total amount paid by student (all time)",
        examples=["1500.00"]
    )
    
    total_pending: str = Field(
        description="Total amount pending (invoiced - paid)",
        examples=["3000.00"]
    )
    
    invoices_pending: int = Field(
        description="Count of invoices with status PENDING",
        examples=[1]
    )
    
    invoices_partially_paid: int = Field(
        description="Count of invoices with status PARTIALLY_PAID",
        examples=[1]
    )
    
    invoices_paid: int = Field(
        description="Count of invoices with status PAID",
        examples=[1]
    )
    
    invoices_cancelled: int = Field(
        description="Count of cancelled invoices",
        examples=[0]
    )
    
    invoices_overdue: int = Field(
        description="Count of overdue invoices (computed: now > due_date AND status IN [PENDING, PARTIALLY_PAID])",
        examples=[1]
    )
    
    total_late_fees: str = Field(
        description="Total late fees accrued on overdue invoices (computed)",
        examples=["50.00"]
    )
    
    statement_date: str = Field(
        description="When statement was generated (ISO 8601 UTC)",
        examples=["2024-01-20T15:00:00Z"]
    )
    
    class Config:
        json_schema_extra = {
            "example": {
                "student_id": "550e8400-e29b-41d4-a716-446655440000",
                "student_name": "Juan Pérez García",
                "school_name": "Colegio ABC",
                "total_invoiced": "4500.00",
                "total_paid": "1500.00",
                "total_pending": "3000.00",
                "invoices_pending": 1,
                "invoices_partially_paid": 1,
                "invoices_paid": 1,
                "invoices_cancelled": 0,
                "invoices_overdue": 1,
                "total_late_fees": "50.00",
                "statement_date": "2024-01-20T15:00:00Z"
            }
        }
```

**Route Implementation:**
```python
@router.get(
    "/students/{id}/account-statement",
    response_model=StudentAccountStatementDTO,
    summary="Get student account statement",
    description="""
    Get aggregated financial summary for a student.
    
    ## Calculations
    - **total_invoiced**: SUM(invoices.amount) for all student invoices
    - **total_paid**: SUM(payments.amount) for all invoices
    - **total_pending**: total_invoiced - total_paid
    - **invoices_overdue**: COUNT WHERE now > due_date AND status IN [PENDING, PARTIALLY_PAID]
    - **total_late_fees**: SUM of calculated late fees for overdue invoices
    
    ## Performance
    - Single aggregate query for numeric totals and counts
    - Separate iteration for late fee calculation (only overdue invoices)
    - Cached in Redis for 5 minutes (see ADR-006)
    
    ## Use Cases
    - Dashboard overview for student billing
    - Parent portal account summary
    - "How much does this student owe?" business question
    
    ## Example
    
    ```bash
    curl http://localhost:8000/api/v1/students/550e8400-e29b-41d4-a716-446655440000/account-statement
    ```
    """,
    responses={
        200: {"description": "Account statement generated successfully"},
        404: {
            "description": "Student not found",
            "content": {
                "application/json": {
                    "example": {
                        "detail": "Student 550e8400-e29b-41d4-a716-446655440000 not found"
                    }
                }
            }
        }
    },
    tags=["Students"]
)
async def get_student_account_statement(
    id: str,
    session: AsyncSession = Depends(get_session),
    time_provider: TimeProvider = Depends(get_time_provider),
) -> StudentAccountStatementDTO:
    """Get student account statement endpoint handler."""
    async with UnitOfWork(session) as uow:
        student_id = StudentId.from_string(id)
        
        use_case = GetStudentAccountStatementUseCase()
        statement = await use_case.execute(
            uow, 
            student_id, 
            time_provider.now()
        )
        
        return AccountStatementMapper.to_student_response(statement)
```

#### 3.2.4 School Account Statement

**Endpoint:** `GET /api/v1/schools/{id}/account-statement`

**Response DTO:**
```python
class SchoolAccountStatementDTO(BaseModel):
    """School account statement (aggregated across all students)."""
    
    school_id: str = Field(
        description="School UUID",
        examples=["450e8400-e29b-41d4-a716-446655440000"]
    )
    
    school_name: str = Field(
        description="School name",
        examples=["Colegio ABC"]
    )
    
    total_students: int = Field(
        description="Total number of students (all statuses)",
        examples=[150]
    )
    
    active_students: int = Field(
        description="Number of active students",
        examples=[142]
    )
    
    total_invoiced: str = Field(
        description="Total amount invoiced across all students",
        examples=["225000.00"]
    )
    
    total_paid: str = Field(
        description="Total amount paid by all students",
        examples=["180000.00"]
    )
    
    total_pending: str = Field(
        description="Total amount pending across all students",
        examples=["45000.00"]
    )
    
    invoices_pending: int = Field(
        description="Count of pending invoices (all students)",
        examples=[25]
    )
    
    invoices_partially_paid: int = Field(
        description="Count of partially paid invoices",
        examples=[10]
    )
    
    invoices_paid: int = Field(
        description="Count of paid invoices",
        examples=[115]
    )
    
    invoices_overdue: int = Field(
        description="Count of overdue invoices (all students)",
        examples=[8]
    )
    
    invoices_cancelled: int = Field(
        description="Count of cancelled invoices",
        examples=[2]
    )
    
    total_late_fees: str = Field(
        description="Total late fees accrued across all students",
        examples=["1250.00"]
    )
    
    statement_date: str = Field(
        description="When statement was generated (ISO 8601 UTC)",
        examples=["2024-01-20T15:00:00Z"]
    )
    
    class Config:
        json_schema_extra = {
            "example": {
                "school_id": "450e8400-e29b-41d4-a716-446655440000",
                "school_name": "Colegio ABC",
                "total_students": 150,
                "active_students": 142,
                "total_invoiced": "225000.00",
                "total_paid": "180000.00",
                "total_pending": "45000.00",
                "invoices_pending": 25,
                "invoices_partially_paid": 10,
                "invoices_paid": 115,
                "invoices_overdue": 8,
                "invoices_cancelled": 2,
                "total_late_fees": "1250.00",
                "statement_date": "2024-01-20T15:00:00Z"
            }
        }
```

**Route Implementation:**
```python
@router.get(
    "/schools/{id}/account-statement",
    response_model=SchoolAccountStatementDTO,
    summary="Get school account statement",
    description="""
    Get aggregated financial summary for a school (all students).
    
    ## Business Questions Answered
    - ¿Cuántos alumnos tiene un colegio? (total_students, active_students)
    - ¿Cuánto le deben todos los estudiantes? (total_pending)
    - ¿Cuál es el estado de cuenta del colegio? (full summary)
    
    ## Calculations
    - Aggregates across ALL students in the school
    - Same calculation rules as student account statement
    - Includes student count by status
    
    ## Performance
    - Single aggregate query with JOIN across schools/students/invoices/payments
    - Cached in Redis for 5 minutes (see ADR-006)
    
    ## Example
    
    ```bash
    curl http://localhost:8000/api/v1/schools/450e8400-e29b-41d4-a716-446655440000/account-statement
    ```
    """,
    responses={
        200: {"description": "Account statement generated successfully"},
        404: {
            "description": "School not found",
            "content": {
                "application/json": {
                    "example": {
                        "detail": "School 450e8400-e29b-41d4-a716-446655440000 not found"
                    }
                }
            }
        }
    },
    tags=["Schools"]
)
async def get_school_account_statement(
    id: str,
    session: AsyncSession = Depends(get_session),
    time_provider: TimeProvider = Depends(get_time_provider),
) -> SchoolAccountStatementDTO:
    """Get school account statement endpoint handler."""
    async with UnitOfWork(session) as uow:
        school_id = SchoolId.from_string(id)
        
        use_case = GetSchoolAccountStatementUseCase()
        statement = await use_case.execute(
            uow,
            school_id,
            time_provider.now()
        )
        
        return AccountStatementMapper.to_school_response(statement)
```

---

## 4. API Design Conventions

### 4.1 URL Versioning

**Format:** `/api/v{major_version}/{resource}`

**Examples:**
- `/api/v1/schools`
- `/api/v1/students/{id}/account-statement`
- `/api/v1/invoices/{id}/cancel`

**Rationale:**
- Simple and explicit in URLs
- Easy to route different versions to different handlers
- Clear in logs and monitoring
- Supported by all HTTP clients
- No ambiguity about which version is being called

**Versioning Strategy:**
- All new endpoints start with `/api/v1` prefix
- Breaking changes require new version: `/api/v2/...`
- Non-breaking changes (new optional fields) stay in current version
- Support N-1 versions during transition period

### 4.2 Field Naming Conventions

- **snake_case** for all JSON keys (Python convention)
  - `student_id`, `late_fee_policy_monthly_rate`, `created_at`
- **ISO 8601** for timestamps (always UTC with `Z` suffix)
  - `"created_at": "2024-01-15T10:30:00Z"`
- **String decimals** for monetary values (never numbers)
  - `"amount": "1500.00"` (not `1500.00` as number)
- **UUID strings** for identifiers
  - `"id": "550e8400-e29b-41d4-a716-446655440000"`

### 4.3 HTTP Status Codes

| Status | Usage |
|--------|-------|
| 200 OK | Successful GET, PUT operations |
| 201 Created | Successful POST (resource created) |
| 204 No Content | Successful DELETE |
| 400 Bad Request | Business rule violation (e.g., invalid state transition) |
| 404 Not Found | Resource not found |
| 422 Unprocessable Entity | Validation error (type, format, or domain rule) |
| 500 Internal Server Error | Unexpected error (bug or infrastructure) |

**Note on PUT vs PATCH:**
This API uses **PUT for updates** (full resource replacement). PATCH (partial updates) is not supported to keep the API simple and avoid merge semantics complexity. If a field shouldn't change, validate it server-side (e.g., `school_id` is immutable for students).

### 4.4 Pagination (Future - ADR-007)

**Format (planned):**
```
GET /api/v1/invoices?offset=20&limit=50
```

**Response structure:**
```json
{
  "items": [...],
  "total": 150,
  "offset": 20,
  "limit": 50
}
```

**See:** [ADR-007: Pagination Strategy](ADR-007-pagination.md) (planned)

### 4.5 Filtering (Future - ADR-007)

**Format (planned):**
```
GET /api/v1/invoices?student_id=550e8400...&status=pending
```

**See:** [ADR-007: Pagination Strategy](ADR-007-pagination.md) (planned)

---

## 5. Error Handling

### 5.1 Strategy: Global Exception Handlers

We use **global exception handlers** to translate domain exceptions into HTTP responses. This keeps route handlers clean and centralizes error handling logic.

**Architecture:**
```
Domain Layer                    Entrypoints Layer
    │                                  │
    │  Domain Exceptions               │  Global Exception Handlers
    │  (protocol-agnostic)             │  (HTTP-specific)
    │                                  │
    ├─ InvoiceNotFoundError  ────────► 404 Not Found
    ├─ InvalidInvoiceAmountError ────► 422 Unprocessable Entity
    ├─ InvalidStateTransitionError ──► 400 Bad Request
    └─ Exception (catch-all) ────────► 500 Internal Server Error
```

### 5.2 Domain Exceptions

Already defined in [ADR-002: Domain Model](ADR-002-domain-model.md#domain-exception-hierarchy):

```python
# domain/exceptions.py

class DomainError(Exception):
    """Base class for all domain errors."""
    pass

# Not Found errors (404)
class SchoolNotFoundError(DomainError):
    pass

class StudentNotFoundError(DomainError):
    pass

class InvoiceNotFoundError(DomainError):
    pass

class PaymentNotFoundError(DomainError):
    pass

# Validation errors (422)
class InvalidInvoiceAmountError(DomainError):
    pass

class InvalidPaymentAmountError(DomainError):
    pass

class InvalidInvoiceDataError(DomainError):
    pass

class InvalidStudentDataError(DomainError):
    pass

class InvalidSchoolDataError(DomainError):
    pass

class InvalidTimestampError(DomainError):
    pass

class PaymentExceedsBalanceError(DomainError):
    pass

# Business rule violations (400)
class InvalidStateTransitionError(DomainError):
    pass

class CannotPayCancelledInvoiceError(DomainError):
    pass
```

### 5.3 Global Exception Handlers

Registered in FastAPI app initialization:

```python
# entrypoints/http/app.py

from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
from mattilda_challenge.domain.exceptions import (
    DomainError,
    SchoolNotFoundError,
    StudentNotFoundError,
    InvoiceNotFoundError,
    PaymentNotFoundError,
    InvalidInvoiceAmountError,
    InvalidPaymentAmountError,
    InvalidInvoiceDataError,
    InvalidStudentDataError,
    InvalidTimestampError,
    PaymentExceedsBalanceError,
    InvalidStateTransitionError,
    CannotPayCancelledInvoiceError,
)

app = FastAPI(...)


# 404 Not Found errors
@app.exception_handler(SchoolNotFoundError)
@app.exception_handler(StudentNotFoundError)
@app.exception_handler(InvoiceNotFoundError)
@app.exception_handler(PaymentNotFoundError)
async def handle_not_found(request: Request, exc: DomainError) -> JSONResponse:
    """Handle resource not found errors."""
    return JSONResponse(
        status_code=404,
        content={"detail": str(exc)}
    )


# 422 Validation errors (malformed/invalid input values)
@app.exception_handler(InvalidInvoiceAmountError)
@app.exception_handler(InvalidPaymentAmountError)
@app.exception_handler(InvalidInvoiceDataError)
@app.exception_handler(InvalidStudentDataError)
@app.exception_handler(InvalidTimestampError)
async def handle_validation_error(request: Request, exc: DomainError) -> JSONResponse:
    """Handle input validation errors."""
    return JSONResponse(
        status_code=422,
        content={"detail": str(exc)}
    )


# 400 Business rule violations (valid input, violates domain constraints)
@app.exception_handler(InvalidStateTransitionError)
@app.exception_handler(CannotPayCancelledInvoiceError)
@app.exception_handler(PaymentExceedsBalanceError)
async def handle_business_rule_violation(request: Request, exc: DomainError) -> JSONResponse:
    """Handle business rule violations."""
    return JSONResponse(
        status_code=400,
        content={"detail": str(exc)}
    )


# 500 Unexpected errors (catch-all)
@app.exception_handler(Exception)
async def handle_unexpected_error(request: Request, exc: Exception) -> JSONResponse:
    """
    Catch-all for unexpected errors.
    
    Logs error for debugging but returns generic message to client.
    """
    # Log error with full context
    logger.error(
        "unexpected_error",
        error_type=type(exc).__name__,
        message=str(exc),
        path=request.url.path,
        exc_info=True  # Include stack trace
    )
    
    return JSONResponse(
        status_code=500,
        content={"detail": "Internal server error"}
    )
```

### 5.4 Error Response Format

**Simple format (sufficient for REST-only API):**

```json
// Not Found (404)
{
  "detail": "Invoice 550e8400-e29b-41d4-a716-446655440000 not found"
}

// Validation Error (422)
{
  "detail": "Invoice amount must be positive, got Decimal('-100.00')"
}

// Business Rule Violation (400)
{
  "detail": "Cannot mark invoice as paid from status: cancelled"
}

// Pydantic Validation Error (422, handled by FastAPI)
{
  "detail": [
    {
      "loc": ["body", "amount"],
      "msg": "string does not match regex",
      "type": "value_error.str.regex"
    }
  ]
}
```

### 5.5 Error Handling in Routes

**Routes do NOT catch exceptions** - they let domain exceptions propagate to global handlers:

```python
# âœ… Correct: Let exceptions propagate
@router.post("/invoices")
async def create_invoice(
    request: InvoiceCreateRequestDTO,
    session: AsyncSession = Depends(get_session),
    time_provider: TimeProvider = Depends(get_time_provider),
) -> InvoiceResponseDTO:
    """Create invoice endpoint handler."""
    async with UnitOfWork(session) as uow:
        domain_request = InvoiceMapper.to_create_request(request, time_provider.now())
        
        use_case = CreateInvoiceUseCase()
        invoice = await use_case.execute(uow, domain_request)
        # If student not found, StudentNotFoundError propagates
        # Global handler catches and returns 404
        
        return InvoiceMapper.to_response(invoice, time_provider.now())


# âŒ Wrong: Catching exceptions in route
@router.post("/invoices")
async def create_invoice(...):
    try:
        # ... execute use case ...
    except StudentNotFoundError as e:
        raise HTTPException(status_code=404, detail=str(e))
    except InvalidInvoiceAmountError as e:
        raise HTTPException(status_code=422, detail=str(e))
    # This duplicates global handler logic!
```

### 5.6 Validation Responsibility Split

**HTTP Status Code Semantics:**

Clear distinction between validation errors and business rule violations:

| Status | Usage | Example Errors |
|--------|-------|----------------|
| **422 Unprocessable Entity** | Malformed or invalid *input values* | Type mismatch, format error, range violation, negative amounts, non-UTC timestamps |
| **400 Bad Request** | Valid input that violates *domain rules* | Invalid state transition, cannot pay cancelled invoice, payment exceeds balance |
| **404 Not Found** | Resource does not exist | Invoice not found, student not found |
| **500 Internal Server Error** | Unexpected errors (bugs, infrastructure) | Uncaught exceptions |

**Rationale:**
- **422**: Input didn't pass validation (client should fix the format/value)
- **400**: Input is well-formed but violates business constraints (client should understand the rule)

**Pydantic (DTO Layer):**
- Type validation (string, int, etc.)
- Format validation (regex patterns)
- Range validation (min, max)
- Required vs optional fields

```python
class InvoiceCreateRequestDTO(BaseModel):
    amount: str = Field(
        pattern=r"^\d+\.\d{2}$"  # Pydantic validates format
    )
    
    late_fee_policy_monthly_rate: str = Field(
        pattern=r"^[01]\.\d{2,4}$"  # Pydantic validates format
    )
```

**Domain Layer:**
- Business rule validation
- Cross-field validation
- State transition validation
- Invariant enforcement

```python
class Invoice:
    def __post_init__(self) -> None:
        # Domain validates business rules
        if not isinstance(self.amount, Decimal):
            raise InvalidInvoiceAmountError(...)
        
        if self.amount <= Decimal("0"):
            raise InvalidInvoiceAmountError(...)
        
        validate_utc_timestamp(self.due_date, "due_date")
```

### 5.7 Rationale: Why This Approach?

**✅ Pros:**
- Simple and pragmatic (sufficient for REST-only API)
- Follows FastAPI best practices
- Keeps domain pure (no HTTP concepts)
- Global handlers keep routes clean
- Easy to understand in code review
- Centralized error handling logic

**âš ï¸ Limitations:**
- Not suitable for multi-protocol APIs (GraphQL, gRPC)
- No error codes for i18n (not needed for this scope)
- No structured multi-field validation errors (Pydantic handles this)

**When to reconsider:**
- Adding GraphQL or gRPC endpoints → Use error translation layer (see reference ADR)
- Need for i18n → Add error codes to domain exceptions
- Complex multi-field validation → Structured error format with field-level details

---

## 6. OpenAPI Documentation Strategy

### 6.1 Documentation Layers

FastAPI automatically generates OpenAPI documentation from code. We enhance it at three layers:

**Layer 1: FastAPI App Metadata**
```python
# entrypoints/http/app.py

app = FastAPI(
    title="Mattilda Challenge API",
    description="""
    School billing system API for managing schools, students, invoices, and payments.
    
    ## Features
    - School and student management
    - Invoice generation and tracking
    - Payment recording with partial payment support
    - Account statement generation (aggregated financial summaries)
    - Late fee calculation for overdue invoices
    
    ## Financial Precision
    All monetary values use exact decimal arithmetic (never floating point).
    Amounts are represented as strings in API requests/responses to preserve precision.
    
    ## Identifiers
    All entities use UUID-based identifiers for security and distributed generation.
    UUIDs are represented as strings in API requests/responses.
    
    ## Timestamps
    All timestamps use ISO 8601 format in UTC timezone (always ending with 'Z').
    Example: `2024-01-15T10:30:00Z`
    
    ## Business Domain
    - **Schools (Colegios)**: Educational institutions
    - **Students (Estudiantes)**: Students enrolled in schools
    - **Invoices (Facturas)**: Bills issued to students
    - **Payments (Pagos)**: Monetary transactions against invoices
    
    ## Key Business Questions Answered
    - ¿Cuánto le debe un estudiante a un colegio? → Student account statement
    - ¿Cuánto le deben todos los estudiantes? → School account statement
    - ¿Cuántos alumnos tiene un colegio? → School account statement
    """,
    version="1.0.0",
    docs_url="/docs",           # Swagger UI
    redoc_url="/redoc",         # ReDoc alternative UI
    openapi_url="/openapi.json", # OpenAPI schema JSON
    contact={
        "name": "Mattilda Challenge Team",
        "email": "dev@mattilda-challenge.com"
    },
    license_info={
        "name": "MIT",
        "url": "https://opensource.org/licenses/MIT"
    }
)
```

**Layer 2: Rich DTO Schemas**
```python
# entrypoints/http/dtos/invoice_dtos.py

class InvoiceCreateRequestDTO(BaseModel):
    """Request to create a new invoice for a student."""
    
    student_id: str = Field(
        description="Student UUID who will be invoiced",
        examples=["550e8400-e29b-41d4-a716-446655440000"]
    )
    
    amount: str = Field(
        description="Invoice amount in MXN (decimal as string, always 2 decimal places)",
        examples=["1500.00", "2350.50", "10000.00"],
        pattern=r"^\d+\.\d{2}$"
    )
    
    # ... other fields with descriptions and examples
    
    class Config:
        json_schema_extra = {
            "examples": [
                {
                    "student_id": "550e8400-e29b-41d4-a716-446655440000",
                    "amount": "1500.00",
                    "due_date": "2024-02-15T00:00:00Z",
                    "description": "February 2024 Tuition",
                    "late_fee_policy_monthly_rate": "0.05"
                },
                {
                    "student_id": "550e8400-e29b-41d4-a716-446655440000",
                    "amount": "250.00",
                    "due_date": "2024-02-01T00:00:00Z",
                    "description": "Lab Materials Fee",
                    "late_fee_policy_monthly_rate": "0.00"
                }
            ]
        }
```

**Layer 3: Route Metadata**
```python
# entrypoints/http/routes/invoices.py

@router.post(
    "/invoices",
    response_model=InvoiceResponseDTO,
    status_code=status.HTTP_201_CREATED,
    summary="Create new invoice",
    description="""
    Create a new invoice for a student.
    
    ## Business Rules
    - Student must exist and be ACTIVE
    - Amount must be positive
    - Due date must be in the future or today
    
    ## Examples
    
    Create tuition invoice:
    ```bash
    curl -X POST http://localhost:8000/api/v1/invoices \
      -H "Content-Type: application/json" \
      -d '{...}'
    ```
    """,
    responses={
        201: {"description": "Invoice created successfully", ...},
        404: {"description": "Student not found", ...},
        422: {"description": "Validation error", ...}
    },
    tags=["Invoices"]
)
async def create_invoice(...):
    ...
```

### 6.2 Documentation Checklist

For each endpoint:
- [ ] Route has `summary` (one-line description)
- [ ] Route has `description` (detailed explanation with examples)
- [ ] Route has `responses` dict (document all status codes)
- [ ] Route has `tags` (for grouping in docs)
- [ ] DTOs have `Field()` with `description` and `examples`
- [ ] DTOs have `class Config` with `json_schema_extra["examples"]`
- [ ] At least 2 examples provided (minimal + complex)
- [ ] Error responses documented with example payloads
- [ ] Tested in Swagger UI with "Try it out" feature

### 6.3 Accessing Documentation

Once server is running:

```bash
# Start server
make up

# Access documentation
open http://localhost:8000/docs        # Swagger UI (interactive)
open http://localhost:8000/redoc       # ReDoc (better for reading)
curl http://localhost:8000/openapi.json # OpenAPI schema (for tools)
```

**Swagger UI Features:**
- Interactive "Try it out" buttons
- Execute requests directly from browser
- See request/response examples
- View schema definitions

**ReDoc Features:**
- Better for reading/printing
- Three-panel layout
- Search functionality
- Cleaner presentation

### 6.4 Exporting for External Tools

**For Postman/Insomnia:**
1. Visit `http://localhost:8000/openapi.json`
2. Copy the JSON
3. In Postman: Import → Paste Raw Text → Import
4. All endpoints automatically configured with examples

**For Client Generation:**
```bash
# Generate Python client
openapi-generator generate -i http://localhost:8000/openapi.json \
  -g python -o ./client

# Generate TypeScript client
openapi-generator generate -i http://localhost:8000/openapi.json \
  -g typescript-axios -o ./client
```

---

## 7. Controller Pattern: Parse → Execute → Map → Return

All route handlers follow the same pattern - **no business logic in controllers**:

```python
@router.post("/invoices")
async def create_invoice(
    request: InvoiceCreateRequestDTO,           # 1. Parse (FastAPI + Pydantic)
    session: AsyncSession = Depends(get_session),
    time_provider: TimeProvider = Depends(get_time_provider),
) -> InvoiceResponseDTO:
    """Create invoice endpoint handler."""
    async with UnitOfWork(session) as uow:
        # 2. Map DTO to domain request
        domain_request = InvoiceMapper.to_create_request(
            request,
            time_provider.now()
        )
        
        # 3. Execute use case
        use_case = CreateInvoiceUseCase()
        invoice = await use_case.execute(uow, domain_request)
        
        # 4. Map domain entity to response DTO
        return InvoiceMapper.to_response(invoice, time_provider.now())
```

**Controller responsibilities:**
- ✅ Orchestrate request flow
- ✅ Delegate to mapper for DTO ↔ domain translation
- ✅ Delegate to use case for business logic
- ✅ Return mapped response

**Controller does NOT:**
- ❌ Contain business logic
- ❌ Perform inline Decimal conversions
- ❌ Make decisions about domain behavior
- ❌ Access repositories directly
- ❌ Catch domain exceptions (global handlers do this)

---

## 8. Decimal Boundary Enforcement

**Summary:** All monetary values use exact decimal arithmetic throughout the system. This critical invariant is defined in [ADR-002: Domain Model Design - Monetary Values](ADR-002-domain-model.md#1-monetary-values---decimal-arithmetic-system-wide). This section describes how the REST layer enforces the boundary.

**REST Layer Responsibilities:**
- Accept monetary values as **strings** in request DTOs
- Convert to `Decimal` at the boundary (in mappers)
- Convert back to **strings** in response DTOs

### 8.1 The Problem (Brief)

Binary floating-point cannot represent decimals exactly (`0.1 + 0.2 = 0.30000000000000004`). In billing systems, this causes precision loss, rounding drift, and failed audits.

**See [ADR-002](ADR-002-domain-model.md#1-monetary-values---decimal-arithmetic-system-wide) for complete rationale.**

### 8.2 REST Boundary Pattern

```python
# Request DTO - string to preserve precision
class InvoiceCreateRequestDTO(BaseModel):
    amount: str = Field(
        pattern=r"^\d+\.\d{2}$"  # Enforce format
    )

# Mapper - convert at boundary
class InvoiceMapper:
    @staticmethod
    def to_create_request(dto: InvoiceCreateRequestDTO, now: datetime):
        return CreateInvoiceRequest(
            amount=Decimal(dto.amount),  # âœ… str → Decimal
            ...
        )

# Domain - always Decimal
@dataclass(frozen=True, slots=True)
class Invoice:
    amount: Decimal  # âœ… Never float
    
    def __post_init__(self) -> None:
        if not isinstance(self.amount, Decimal):
            raise InvalidInvoiceAmountError(
                f"Amount must be Decimal, got {type(self.amount).__name__}"
            )

# Response DTO - string for JSON
class InvoiceResponseDTO(BaseModel):
    amount: str  # âœ… Decimal → str

# Mapper - convert at boundary
class InvoiceMapper:
    @staticmethod
    def to_response(invoice: Invoice, now: datetime):
        return InvoiceResponseDTO(
            amount=str(invoice.amount),  # âœ… Decimal → str
            ...
        )
```

### 8.3 Enforcement Rules

**DTO Layer (entrypoints/http/dtos/):**
- All monetary fields: `str` type
- Regex pattern validation: `r"^\d+\.\d{2}$"`
- Examples in documentation: `"1500.00"`

**Mapper Layer (entrypoints/http/mappers/):**
- Inbound: `Decimal(dto.amount)` - convert string to Decimal
- Outbound: `str(entity.amount)` - convert Decimal to string

**Domain & Application Layers:**
- All monetary fields: `Decimal` type
- Type validation in `__post_init__`: `isinstance(self.amount, Decimal)`
- No float types anywhere

**Infrastructure Layer (database):**
- All monetary columns: `NUMERIC(12, 2)`
- SQLAlchemy automatically handles Decimal ↔ NUMERIC

### 8.4 Testing Decimal Boundary

```python
def test_mapper_converts_string_to_decimal():
    """Test mapper converts amount string to Decimal."""
    dto = InvoiceCreateRequestDTO(
        student_id="550e8400-e29b-41d4-a716-446655440000",
        amount="1500.00",  # String input
        ...
    )
    
    request = InvoiceMapper.to_create_request(dto, now)
    
    assert isinstance(request.amount, Decimal)
    assert request.amount == Decimal("1500.00")


def test_mapper_converts_decimal_to_string():
    """Test mapper converts Decimal to string in response."""
    invoice = Invoice(
        amount=Decimal("1500.00"),  # Decimal in domain
        ...
    )
    
    response = InvoiceMapper.to_response(invoice, now)
    
    assert isinstance(response.amount, str)
    assert response.amount == "1500.00"


def test_domain_rejects_float_amount():
    """Test domain validation rejects float amounts."""
    with pytest.raises(InvalidInvoiceAmountError) as exc:
        Invoice(
            amount=1500.00,  # Float - should be Decimal
            ...
        )
    
    assert "Amount must be Decimal" in str(exc.value)
```

---

## 9. Future Enhancements

The following features are **out of scope** for initial implementation but documented for future reference:

### 9.1 Caching Strategy (ADR-006 - Planned)

**Scope:**
- Cache account statements in Redis (5-minute TTL)
- Cache key format: `account_statement:student:{uuid}` and `account_statement:school:{uuid}`
- Invalidate on invoice/payment changes

**See:** [ADR-006: Caching Strategy](ADR-006-caching-strategy.md) (planned)

### 9.2 Pagination (ADR-007 - Planned)

**Scope:**
- Offset-based pagination for list endpoints
- Default limit: 20, max limit: 200
- Response includes `total`, `offset`, `limit` metadata

**Format:**
```
GET /api/v1/invoices?offset=20&limit=50
```

**See:** [ADR-007: Pagination Strategy](ADR-007-pagination.md) (planned)

### 9.3 Authentication (Out of Scope)

**Note:** Authentication is intentionally **out of scope** for this challenge (see README.md).

If implemented in the future, it would include:
- JWT-based authentication
- Role-based access control (school admin, staff, parent)
- Protected endpoints with `Depends(get_current_user)`

### 9.4 Observability

**Scope (optional):**
- Structured logging with context
- Health check endpoint with dependency status
- Prometheus metrics endpoint
- Request ID tracing

**Health Check Example:**
```json
GET /health

{
  "status": "healthy",
  "version": "1.0.0",
  "dependencies": {
    "database": "healthy",
    "redis": "healthy"
  },
  "timestamp": "2024-01-20T15:00:00Z"
}
```

---

## Consequences

### Positive

✅ **Thin REST layer** - Controllers are simple orchestrators (parse → execute → map → return)  
✅ **Mapper pattern** - Centralized DTO ↔ domain translation, easy to test  
✅ **Decimal boundary enforced** - All monetary values as strings in DTOs, Decimal in domain  
✅ **Rich documentation** - OpenAPI auto-generated with examples and descriptions  
✅ **Clean error handling** - Global exception handlers, domain exceptions mapped to HTTP status  
✅ **URL versioning** - Explicit `/api/v1` prefix, easy to version breaking changes  
✅ **Testability** - Mappers testable independently, routes testable with mock use cases  
✅ **Maintainability** - Clear patterns that scale as endpoints are added  
✅ **Correctness** - Financial precision guaranteed by Decimal arithmetic  
✅ **FastAPI best practices** - Follows framework conventions and idioms  

### Negative

⚠️ **Boilerplate** - Mapper classes add translation layer (required for Clean Architecture)  
⚠️ **Verbosity** - Rich documentation requires more code (pays off in usability)  
⚠️ **Learning curve** - Team must understand mapper pattern and Decimal handling  
⚠️ **String decimals** - Less ergonomic than numbers in JSON (necessary for precision)  

### Mitigations

- Comprehensive documentation with examples (this ADR + inline docstrings)
- Clear mapper pattern across all endpoints (consistency reduces learning curve)
- Integration tests verify Decimal boundary enforcement
- Swagger UI provides interactive documentation (reduces documentation burden)

---

## Alternatives Considered

### 1. Inline DTO Conversion (No Mappers)

**Approach:** Convert DTOs to domain models inline in route handlers.

```python
@router.post("/invoices")
async def create_invoice(request: InvoiceCreateRequestDTO):
    # Inline conversion
    domain_request = CreateInvoiceRequest(
        student_id=StudentId.from_string(request.student_id),
        amount=Decimal(request.amount),
        ...
    )
    ...
```

**Rejected because:**
- ❌ Duplicates conversion logic across routes
- ❌ Controllers become longer and harder to read
- ❌ Harder to test conversions independently
- ❌ Violates DRY principle

### 2. DTO Methods for Conversion

**Approach:** Add `to_domain()` and `from_domain()` methods on DTOs.

```python
class InvoiceCreateRequestDTO(BaseModel):
    def to_domain(self, now: datetime) -> CreateInvoiceRequest:
        return CreateInvoiceRequest(
            amount=Decimal(self.amount),
            ...
        )
```

**Rejected because:**
- ❌ Makes DTOs aware of domain models (violates Clean Architecture)
- ❌ Outer layer (entrypoints) shouldn't know inner layer details
- ❌ DTOs become coupled to domain evolution

### 3. Numeric Types for Monetary Values

**Approach:** Use JSON numbers for amounts, rely on Python's automatic conversion.

```json
{
  "amount": 1500.00
}
```

**Rejected because:**
- ❌ Binary floating-point precision loss
- ❌ Non-deterministic calculations
- ❌ Cannot guarantee exact decimal arithmetic
- ❌ Violates ADR-002 monetary value invariants

### 4. Error Codes and i18n Support

**Approach:** Include error codes in responses for internationalization.

```json
{
  "detail": "Invoice not found",
  "code": "INVOICE_NOT_FOUND",
  "resource": "invoice",
  "identifier": "550e8400..."
}
```

**Deferred because:**
- Not required for single-language API
- Adds complexity without immediate benefit
- Can be added later if needed
- Simple format sufficient for REST-only API

### 5. Header-Based Versioning

**Approach:** Use `Accept` header for API versioning.

```
Accept: application/vnd.mattilda.v1+json
```

**Rejected because:**
- ❌ Harder to test with curl/browser
- ❌ Less visible in logs and monitoring
- ❌ Easy to forget in client code
- ❌ URL versioning is simpler and more explicit

---

## Implementation Checklist

### Phase 1: Infrastructure Setup
- [ ] Create FastAPI app with metadata in `entrypoints/http/app.py`
- [ ] Configure OpenAPI docs (`/docs`, `/redoc`, `/openapi.json`)
- [ ] Add global exception handlers for domain errors
- [ ] Create `dependencies.py` with DI factory functions
- [ ] Create `entrypoints/http/dtos/` folder structure
- [ ] Create `entrypoints/http/mappers/` folder structure
- [ ] Create `entrypoints/http/routes/` folder structure

### Phase 2: Schools Endpoints
- [ ] Create `school_dtos.py` with request/response DTOs
- [ ] Create `school_mapper.py` with `SchoolMapper` class
- [ ] Create `routes/schools.py` with CRUD endpoints
- [ ] Add route documentation (summary, description, examples)
- [ ] Create unit tests for `SchoolMapper`
- [ ] Create integration tests for school endpoints
- [ ] Test Swagger UI documentation

### Phase 3: Students Endpoints
- [ ] Create `student_dtos.py` with request/response DTOs
- [ ] Create `student_mapper.py` with `StudentMapper` class
- [ ] Create `routes/students.py` with CRUD endpoints
- [ ] Add route documentation
- [ ] Create unit tests for `StudentMapper`
- [ ] Create integration tests for student endpoints

### Phase 4: Invoices Endpoints
- [ ] Create `invoice_dtos.py` with request/response DTOs
- [ ] Create `invoice_mapper.py` with `InvoiceMapper` class
- [ ] Create `routes/invoices.py` with CRUD + cancel endpoints
- [ ] Add route documentation with late fee examples
- [ ] Create unit tests for `InvoiceMapper` (verify Decimal conversion)
- [ ] Create integration tests for invoice endpoints
- [ ] Test computed fields (`is_overdue`, `late_fee`)

### Phase 5: Payments Endpoints
- [ ] Create `payment_dtos.py` with request/response DTOs
- [ ] Create `payment_mapper.py` with `PaymentMapper` class
- [ ] Create `routes/payments.py` with record payment endpoint
- [ ] Add route documentation with partial payment examples
- [ ] Create unit tests for `PaymentMapper`
- [ ] Create integration tests for payment recording
- [ ] Test atomic transaction behavior (UoW)

### Phase 6: Account Statements
- [ ] Create `account_statement_dtos.py` with student/school DTOs
- [ ] Create `account_statement_mapper.py` with `AccountStatementMapper` class
- [ ] Add student account statement endpoint to `routes/students.py`
- [ ] Add school account statement endpoint to `routes/schools.py`
- [ ] Add route documentation explaining calculations
- [ ] Create unit tests for `AccountStatementMapper`
- [ ] Create integration tests for account statements
- [ ] Test aggregation calculations (total_invoiced, total_paid, etc.)

### Phase 7: Health & Monitoring
- [ ] Create `routes/health.py` with health check endpoint
- [ ] Test health check response
- [ ] Verify OpenAPI schema generation at `/openapi.json`
- [ ] Test interactive "Try it out" in Swagger UI
- [ ] Export OpenAPI schema to Postman/Insomnia

### Phase 8: Documentation
- [ ] Update README with API quick start examples
- [ ] Add curl examples for common operations
- [ ] Document Decimal boundary enforcement
- [ ] Document error handling strategy
- [ ] Add troubleshooting guide
- [ ] Create developer onboarding guide

---

## Testing Strategy

### Unit Tests

**Mapper Tests:**
```python
# tests/unit/entrypoints/http/mappers/test_invoice_mapper.py

def test_to_create_request_converts_string_to_decimal():
    """Test mapper converts amount string to Decimal."""
    dto = InvoiceCreateRequestDTO(
        student_id="550e8400-e29b-41d4-a716-446655440000",
        amount="1500.00",
        ...
    )
    
    request = InvoiceMapper.to_create_request(dto, now)
    
    assert isinstance(request.amount, Decimal)
    assert request.amount == Decimal("1500.00")


def test_to_response_converts_decimal_to_string():
    """Test mapper converts Decimal to string."""
    invoice = Invoice(amount=Decimal("1500.00"), ...)
    
    response = InvoiceMapper.to_response(invoice, now)
    
    assert isinstance(response.amount, str)
    assert response.amount == "1500.00"


def test_to_response_includes_computed_fields():
    """Test response includes computed is_overdue and late_fee."""
    invoice = Invoice(
        amount=Decimal("1500.00"),
        due_date=datetime(2024, 1, 1, tzinfo=UTC),
        late_fee_policy=LateFeePolicy(monthly_rate=Decimal("0.05")),
        ...
    )
    
    # 15 days overdue
    now = datetime(2024, 1, 16, tzinfo=UTC)
    response = InvoiceMapper.to_response(invoice, now)
    
    assert response.is_overdue is True
    assert response.late_fee == "37.50"  # 1500 × 0.05 × (15/30)
```

**Route Tests (with mock use cases):**
```python
# tests/unit/entrypoints/http/routes/test_invoices.py

from unittest.mock import AsyncMock, patch

@patch("mattilda_challenge.entrypoints.http.routes.invoices.CreateInvoiceUseCase")
async def test_create_invoice_returns_201(mock_use_case_class, client):
    """Test create invoice endpoint returns 201."""
    mock_use_case = AsyncMock()
    mock_use_case.execute.return_value = Invoice(...)
    mock_use_case_class.return_value = mock_use_case
    
    response = client.post(
        "/api/v1/invoices",
        json={
            "student_id": "550e8400-e29b-41d4-a716-446655440000",
            "amount": "1500.00",
            ...
        }
    )
    
    assert response.status_code == 201
    assert response.json()["amount"] == "1500.00"
```

### Integration Tests

**End-to-End Flow:**
```python
# tests/integration/test_invoice_workflow.py

async def test_create_invoice_and_record_payment(client, db_session):
    """Test complete invoice workflow from creation to payment."""
    # Create school
    school = School.create(name="Colegio ABC", address="...", now=now)
    await school_repo.save(school)
    
    # Create student
    student = Student.create(school_id=school.id, ..., now=now)
    await student_repo.save(student)
    
    # Create invoice via API
    response = client.post(
        "/api/v1/invoices",
        json={
            "student_id": str(student.id),
            "amount": "1500.00",
            ...
        }
    )
    assert response.status_code == 201
    invoice_id = response.json()["id"]
    
    # Record partial payment via API
    response = client.post(
        "/api/v1/payments",
        json={
            "invoice_id": invoice_id,
            "amount": "500.00",
            ...
        }
    )
    assert response.status_code == 201
    
    # Verify invoice status updated
    response = client.get(f"/api/v1/invoices/{invoice_id}")
    assert response.json()["status"] == "partially_paid"
    
    # Record final payment
    response = client.post(
        "/api/v1/payments",
        json={
            "invoice_id": invoice_id,
            "amount": "1000.00",
            ...
        }
    )
    assert response.status_code == 201
    
    # Verify invoice marked as paid
    response = client.get(f"/api/v1/invoices/{invoice_id}")
    assert response.json()["status"] == "paid"
```

---

## References

- [ADR-001: Project Initialization & Structure](ADR-001-project-initialization.md)
- [ADR-002: Domain Model Design](ADR-002-domain-model.md)
- [ADR-003: Time Provider Interface and Implementation](ADR-003-time-provider.md)
- [ADR-004: PostgreSQL Persistence with SQLAlchemy and Alembic](ADR-004-postgresql-persistence.md)
- [ADR-006: Caching Strategy](ADR-006-caching-strategy.md) (planned)
- [ADR-007: Pagination Strategy](ADR-007-pagination.md) (planned)
- [ADR-008: Observability Strategy](ADR-008.md)
- [FastAPI Documentation](https://fastapi.tiangolo.com/)
- [OpenAPI Specification](https://swagger.io/specification/)
- [Pydantic Documentation](https://docs.pydantic.dev/)
- [Clean Architecture by Robert C. Martin](https://www.amazon.com/Clean-Architecture-Craftsmans-Software-Structure/dp/0134494164)
- [Martin Fowler's Mapper Pattern](https://martinfowler.com/eaaCatalog/dataMapper.html)
