# ADR-007: Pagination Strategy

## Status

Accepted

## Context

The Mattilda Challenge system exposes list endpoints for schools, students, invoices, and payments. As data grows, these endpoints must support pagination to:

- **Prevent unbounded responses**: Returning all records is unsustainable for large datasets
- **Enable efficient UI navigation**: Support "Page X of Y" patterns in admin interfaces
- **Reduce server load**: Limit memory and CPU usage per request
- **Support filtering**: Allow clients to narrow results before pagination

This ADR defines the pagination approach, filtering conventions, sorting behavior, and response structure for all list endpoints.

### Requirements (from Challenge PDF)

The API must support:

- **Paginación** en endpoints que listan información (Pagination in endpoints that list information)

This is listed as an optional feature ("EXTRAS - no obligatorios, pero suman puntos") that adds value to the solution.

### Endpoints Requiring Pagination

| Endpoint | Expected Volume | Common Filters |
|----------|-----------------|----------------|
| `GET /api/v1/schools` | Low (~10-100) | name |
| `GET /api/v1/students` | Medium (~100-10,000 per school) | school_id, status |
| `GET /api/v1/invoices` | High (~1,000-100,000) | student_id, school_id, status, due_date range |
| `GET /api/v1/payments` | High (~1,000-100,000) | invoice_id, payment_date range |

### Related ADRs

- **[ADR-001](ADR-001-project-initialization.md)**: Clean Architecture (pagination logic in application layer)
- **[ADR-004](ADR-004-postgresql-persistence.md)**: PostgreSQL persistence (indexes, query patterns)
- **[ADR-005](ADR-005-rest-api-design.md)**: REST API design (endpoint structure, response conventions)

---

## Decision

### 1. Pagination Strategy: Offset-Based

We use **offset-based pagination** with explicit `offset` and `limit` query parameters.

**Format:**
```
GET /api/v1/invoices?offset=20&limit=50
```

**Why Offset-Based:**
- ✅ Simple to implement and understand
- ✅ Allows jumping to any page directly (good for admin UIs)
- ✅ Easy to display "Page X of Y" in frontend
- ✅ Standard pattern familiar to most developers
- ✅ Sufficient for bounded school billing datasets

**Trade-offs Acknowledged:**
- ⚠️ Performance degrades on very large offsets (`OFFSET 10000` scans 10000 rows)
- ⚠️ Results can shift if data changes between page requests

**Mitigation:** 
- Max offset enforced to prevent abuse
- For this domain (school billing), datasets are naturally bounded and manageable
- Future enhancement: cursor-based pagination if needed for specific use cases

---

### 2. Pagination Parameters

#### 2.1 Query Parameters

| Parameter | Type | Default | Min | Max | Description |
|-----------|------|---------|-----|-----|-------------|
| `offset` | integer | 0 | 0 | 10,000 | Number of records to skip |
| `limit` | integer | 20 | 1 | 200 | Maximum records to return |

**Validation Rules:**
- `offset` must be non-negative integer
- `limit` must be positive integer between 1 and 200
- Invalid values return 422 Unprocessable Entity with descriptive error

**Examples:**
```bash
# First page (default)
GET /api/v1/invoices

# Second page of 50 items
GET /api/v1/invoices?offset=50&limit=50

# Jump to page 5 (assuming 20 per page)
GET /api/v1/invoices?offset=80&limit=20
```

#### 2.2 Response Structure

All paginated endpoints return a consistent response structure:

```json
{
  "items": [
    { "id": "550e8400-e29b-41d4-a716-446655440000", "..." : "..." },
    { "id": "550e8400-e29b-41d4-a716-446655440001", "..." : "..." }
  ],
  "pagination": {
    "offset": 20,
    "limit": 50,
    "total": 150,
    "has_more": true
  }
}
```

| Field | Type | Description |
|-------|------|-------------|
| `items` | array | List of resources for current page |
| `pagination.offset` | integer | Current offset (echo of request) |
| `pagination.limit` | integer | Current limit (echo of request) |
| `pagination.total` | integer | Total count of matching records |
| `pagination.has_more` | boolean | `true` if more records exist beyond current page |

**`total` is part of the contract:**

The `total` field is **always included** and is not optional. This is a deliberate decision: for this domain (school billing with bounded datasets), the `COUNT(*)` overhead is acceptable and the UI benefit (displaying "Page X of Y") is significant. If performance becomes a concern in the future, we may introduce an optional `include_total=false` parameter, but this is out of scope for now.

**`has_more` Calculation:**
```python
has_more = (offset + len(items)) < total
```

**Why include `total`:**
- Enables "Page X of Y" display in UI
- Allows client to calculate total pages
- For this domain, `COUNT(*)` is acceptable (bounded datasets, proper indexes)

---

### 3. Filtering

We use **explicit query parameters** for filtering. Each filterable field has its own parameter.

#### 3.1 Filter Parameters by Endpoint

**Schools (`GET /api/v1/schools`):**

| Parameter | Type | Description |
|-----------|------|-------------|
| `name` | string | Partial match (case-insensitive ILIKE) |

**Students (`GET /api/v1/students`):**

| Parameter | Type | Description |
|-----------|------|-------------|
| `school_id` | UUID string | Exact match |
| `status` | string | Exact match (`active`, `inactive`, `graduated`) |
| `email` | string | Partial match (ILIKE) |

**Invoices (`GET /api/v1/invoices`):**

| Parameter | Type | Description |
|-----------|------|-------------|
| `student_id` | UUID string | Exact match |
| `school_id` | UUID string | Exact match (via student relationship) |
| `status` | string | Exact match (`pending`, `partially_paid`, `paid`, `cancelled`, `overdue`) |
| `due_date_from` | ISO 8601 date | Due date >= value |
| `due_date_to` | ISO 8601 date | Due date <= value |

**Payments (`GET /api/v1/payments`):**

| Parameter | Type | Description |
|-----------|------|-------------|
| `invoice_id` | UUID string | Exact match |
| `payment_date_from` | ISO 8601 date | Payment date >= value |
| `payment_date_to` | ISO 8601 date | Payment date <= value |

#### 3.2 Filter Examples

```bash
# Get all pending invoices for a student
GET /api/v1/invoices?student_id=550e8400-...&status=pending

# Get overdue invoices for a school
GET /api/v1/invoices?school_id=550e8400-...&status=overdue

# Get invoices due in January 2024
GET /api/v1/invoices?due_date_from=2024-01-01&due_date_to=2024-01-31

# Get active students for a school
GET /api/v1/students?school_id=550e8400-...&status=active

# Combine filters with pagination
GET /api/v1/invoices?student_id=550e8400-...&status=pending&offset=0&limit=10
```

#### 3.3 Filter Behavior

- **Multiple filters**: Combined with AND logic
- **Unknown parameters**: Ignored intentionally to allow forward compatibility, at the cost of potentially hiding client typos. This is a deliberate trade-off favoring API evolution over strict validation.
- **Empty/null values**: Parameter omitted = no filter applied
- **Invalid UUIDs**: Return 422 Unprocessable Entity
- **Invalid enum values**: Return 422 with valid options in error message

---

### 4. Sorting

#### 4.1 Sort Parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `sort_by` | string | `created_at` | Field to sort by |
| `sort_order` | string | `desc` | Sort direction (`asc` or `desc`) |

**Critical: Deterministic Ordering**

All `ORDER BY` clauses **must include `id` as a secondary sort key** to guarantee stable ordering. Without this, rows with identical sort values (e.g., same `created_at`) may appear in different positions across requests, causing items to be skipped or duplicated during pagination.

```sql
-- ✅ Correct: deterministic order
ORDER BY created_at DESC, id DESC

-- ❌ Wrong: non-deterministic when created_at ties
ORDER BY created_at DESC
```

This is enforced in the repository layer, not exposed to API clients.

#### 4.2 Sortable Fields by Endpoint

| Endpoint | Sortable Fields | Default |
|----------|-----------------|---------|
| Schools | `name`, `created_at` | `created_at DESC` |
| Students | `last_name`, `first_name`, `email`, `enrollment_date`, `created_at` | `created_at DESC` |
| Invoices | `due_date`, `amount`, `status`, `created_at` | `created_at DESC` |
| Payments | `payment_date`, `amount`, `created_at` | `created_at DESC` |

#### 4.3 Sort Examples

```bash
# Sort invoices by due date (oldest first)
GET /api/v1/invoices?sort_by=due_date&sort_order=asc

# Sort students by last name
GET /api/v1/students?sort_by=last_name&sort_order=asc

# Default sort (newest first)
GET /api/v1/invoices
```

#### 4.4 Sort Validation

- Invalid `sort_by` field: Return 422 with list of valid fields
- Invalid `sort_order`: Return 422 with valid options (`asc`, `desc`)

---

### 5. Implementation Architecture

#### 5.1 Layer Responsibilities

```
┌─────────────────────────────────────────────────────────────┐
│  Entrypoints (HTTP)                                         │
│  - Parse query params into PaginationParams, FilterParams   │
│  - Validate offset, limit, sort_by, sort_order              │
│  - Return PaginatedResponse DTO                             │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│  Application (Use Cases)                                    │
│  - Receive typed params from entrypoint                     │
│  - Pass to repository                                       │
│  - Return domain Page[Entity]                               │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│  Infrastructure (Repository)                                │
│  - Build SQLAlchemy query with filters                      │
│  - Apply ORDER BY, LIMIT, OFFSET                            │
│  - Execute COUNT(*) for total                               │
│  - Return Page[Entity]                                      │
└─────────────────────────────────────────────────────────────┘
```

**Validation Ownership:**

| Concern | Layer | Rationale |
|---------|-------|-----------|
| Type coercion (string → int, string → UUID) | Entrypoint | HTTP parsing concern |
| Range validation (offset ≤ 10k, limit ≤ 200) | Entrypoint | API contract enforcement |
| Enum validation (status values, sort_order) | Entrypoint | OpenAPI schema alignment |
| Sortable fields per endpoint | Entrypoint | Endpoint-specific contract |
| Business rule validation | Use Case | Domain logic |
| SQL column mapping | Infrastructure | Persistence concern |

The infrastructure layer **does not validate**—it assumes inputs are already validated. If an invalid `sort_by` reaches the repository, it's a bug in the upper layers.

#### 5.2 Domain Types (Application Layer)

```python
from __future__ import annotations
from dataclasses import dataclass


@dataclass(frozen=True, slots=True)
class PaginationParams:
    """
    Pagination parameters for list queries.
    
    Immutable value object. Validated at construction.
    """
    offset: int = 0
    limit: int = 20
    
    def __post_init__(self) -> None:
        if self.offset < 0:
            raise ValueError("offset must be non-negative")
        if self.offset > 10_000:
            raise ValueError("offset must not exceed 10,000")
        if self.limit < 1:
            raise ValueError("limit must be at least 1")
        if self.limit > 200:
            raise ValueError("limit must not exceed 200")


@dataclass(frozen=True, slots=True)
class SortParams:
    """
    Sorting parameters for list queries.
    
    Immutable value object. Valid fields checked by use case.
    """
    sort_by: str = "created_at"
    sort_order: str = "desc"  # "asc" or "desc"
    
    def __post_init__(self) -> None:
        if self.sort_order not in ("asc", "desc"):
            raise ValueError("sort_order must be 'asc' or 'desc'")


@dataclass(frozen=True, slots=True)
class Page[T]:
    """
    Paginated result container.
    
    Generic over item type. Immutable.
    
    Note: Page[T] is a domain-agnostic application type, not a REST concern.
    It lives in the application layer and is mapped to REST DTOs at the boundary.
    """
    items: tuple[T, ...]  # Tuple for immutability
    total: int
    offset: int
    limit: int
    
    @property
    def has_more(self) -> bool:
        """True if more items exist beyond current page."""
        return (self.offset + len(self.items)) < self.total
```

#### 5.3 Filter Types (Per Entity)

```python
from __future__ import annotations
from dataclasses import dataclass
from datetime import date
from uuid import UUID


@dataclass(frozen=True, slots=True)
class InvoiceFilters:
    """
    Filter parameters for invoice queries.
    
    All fields optional. None means no filter.
    """
    student_id: UUID | None = None
    school_id: UUID | None = None
    status: str | None = None
    due_date_from: date | None = None
    due_date_to: date | None = None


@dataclass(frozen=True, slots=True)
class StudentFilters:
    """Filter parameters for student queries."""
    school_id: UUID | None = None
    status: str | None = None
    email: str | None = None


@dataclass(frozen=True, slots=True)
class PaymentFilters:
    """Filter parameters for payment queries."""
    invoice_id: UUID | None = None
    payment_date_from: date | None = None
    payment_date_to: date | None = None


@dataclass(frozen=True, slots=True)
class SchoolFilters:
    """Filter parameters for school queries."""
    name: str | None = None
```

#### 5.4 Repository Port Extension

Extend repository ports (from ADR-004) with paginated query methods:

```python
from __future__ import annotations
from abc import ABC, abstractmethod


class InvoiceRepository(ABC):
    """Invoice repository port with pagination support."""
    
    @abstractmethod
    async def get_by_id(self, invoice_id: InvoiceId) -> Invoice | None:
        """Get single invoice by ID."""
        ...
    
    @abstractmethod
    async def save(self, invoice: Invoice) -> Invoice:
        """Save invoice."""
        ...
    
    @abstractmethod
    async def find(
        self,
        filters: InvoiceFilters,
        pagination: PaginationParams,
        sort: SortParams,
    ) -> Page[Invoice]:
        """
        Find invoices matching filters with pagination.
        
        Args:
            filters: Filter criteria (all optional)
            pagination: Offset and limit
            sort: Sort field and direction
            
        Returns:
            Page containing matching invoices and metadata
        """
        ...
```

#### 5.5 PostgreSQL Repository Implementation

```python
from __future__ import annotations
from sqlalchemy import select, func, and_
from sqlalchemy.ext.asyncio import AsyncSession


class PostgresInvoiceRepository(InvoiceRepository):
    """PostgreSQL implementation of invoice repository."""
    
    def __init__(self, session: AsyncSession) -> None:
        self._session = session
    
    async def find(
        self,
        filters: InvoiceFilters,
        pagination: PaginationParams,
        sort: SortParams,
    ) -> Page[Invoice]:
        """Find invoices with filters, pagination, and sorting."""
        
        # Build base query
        query = select(InvoiceModel)
        count_query = select(func.count()).select_from(InvoiceModel)
        
        # Apply filters
        conditions = self._build_conditions(filters)
        if conditions:
            query = query.where(and_(*conditions))
            count_query = count_query.where(and_(*conditions))
        
        # Apply sorting (always include id for deterministic order)
        sort_column = self._get_sort_column(sort.sort_by)
        if sort.sort_order == "desc":
            query = query.order_by(sort_column.desc(), InvoiceModel.id.desc())
        else:
            query = query.order_by(sort_column.asc(), InvoiceModel.id.asc())
        
        # Apply pagination
        query = query.offset(pagination.offset).limit(pagination.limit)
        
        # Execute queries
        result = await self._session.execute(query)
        models = result.scalars().all()
        
        total_result = await self._session.execute(count_query)
        total = total_result.scalar_one()
        
        # Map to domain entities
        items = tuple(InvoiceMapper.to_entity(m) for m in models)
        
        return Page(
            items=items,
            total=total,
            offset=pagination.offset,
            limit=pagination.limit,
        )
    
    def _build_conditions(self, filters: InvoiceFilters) -> list:
        """Build SQLAlchemy filter conditions."""
        conditions = []
        
        if filters.student_id is not None:
            conditions.append(InvoiceModel.student_id == filters.student_id)
        
        if filters.status is not None:
            conditions.append(InvoiceModel.status == filters.status)
        
        if filters.due_date_from is not None:
            conditions.append(InvoiceModel.due_date >= filters.due_date_from)
        
        if filters.due_date_to is not None:
            conditions.append(InvoiceModel.due_date <= filters.due_date_to)
        
        # school_id filter requires join through student
        if filters.school_id is not None:
            conditions.append(
                InvoiceModel.student.has(StudentModel.school_id == filters.school_id)
            )
        
        return conditions
    
    def _get_sort_column(self, sort_by: str):
        """Map sort field name to SQLAlchemy column."""
        column_map = {
            "created_at": InvoiceModel.created_at,
            "due_date": InvoiceModel.due_date,
            "amount": InvoiceModel.amount,
            "status": InvoiceModel.status,
        }
        
        if sort_by not in column_map:
            raise ValueError(f"Invalid sort field: {sort_by}")
        
        return column_map[sort_by]
```

#### 5.6 REST DTOs

```python
from __future__ import annotations
from pydantic import BaseModel, Field


class PaginationResponseDTO(BaseModel):
    """Pagination metadata in response."""
    
    offset: int = Field(description="Current offset")
    limit: int = Field(description="Current limit")
    total: int = Field(description="Total matching records")
    has_more: bool = Field(description="True if more records exist")


class PaginatedInvoiceResponseDTO(BaseModel):
    """Paginated list of invoices."""
    
    items: list[InvoiceResponseDTO] = Field(description="Invoice records")
    pagination: PaginationResponseDTO = Field(description="Pagination metadata")
    
    model_config = {
        "json_schema_extra": {
            "example": {
                "items": [
                    {
                        "id": "550e8400-e29b-41d4-a716-446655440000",
                        "student_id": "550e8400-e29b-41d4-a716-446655440001",
                        "amount": "1500.00",
                        "status": "pending",
                        "due_date": "2024-02-15T00:00:00Z",
                        "created_at": "2024-01-15T10:30:00Z"
                    }
                ],
                "pagination": {
                    "offset": 0,
                    "limit": 20,
                    "total": 150,
                    "has_more": True
                }
            }
        }
    }
```

#### 5.7 FastAPI Route Example

```python
from __future__ import annotations
from fastapi import APIRouter, Query, Depends
from uuid import UUID


router = APIRouter(prefix="/api/v1/invoices", tags=["Invoices"])


@router.get(
    "",
    response_model=PaginatedInvoiceResponseDTO,
    summary="List invoices",
    description="Get paginated list of invoices with optional filters.",
)
async def list_invoices(
    # Pagination
    offset: int = Query(default=0, ge=0, le=10_000, description="Records to skip"),
    limit: int = Query(default=20, ge=1, le=200, description="Max records to return"),
    
    # Sorting
    sort_by: str = Query(
        default="created_at",
        description="Field to sort by",
        enum=["created_at", "due_date", "amount", "status"],
    ),
    sort_order: str = Query(
        default="desc",
        description="Sort direction",
        enum=["asc", "desc"],
    ),
    
    # Filters
    student_id: UUID | None = Query(default=None, description="Filter by student"),
    school_id: UUID | None = Query(default=None, description="Filter by school"),
    status: str | None = Query(
        default=None,
        description="Filter by status",
        enum=["pending", "partially_paid", "paid", "cancelled", "overdue"],
    ),
    due_date_from: date | None = Query(default=None, description="Due date from (inclusive)"),
    due_date_to: date | None = Query(default=None, description="Due date to (inclusive)"),
    
    # Dependencies
    uow: UnitOfWork = Depends(get_unit_of_work),
) -> PaginatedInvoiceResponseDTO:
    """List invoices with pagination and filters."""
    
    # Build typed params
    pagination = PaginationParams(offset=offset, limit=limit)
    sort = SortParams(sort_by=sort_by, sort_order=sort_order)
    filters = InvoiceFilters(
        student_id=student_id,
        school_id=school_id,
        status=status,
        due_date_from=due_date_from,
        due_date_to=due_date_to,
    )
    
    # Execute use case
    use_case = ListInvoicesUseCase()
    page = await use_case.execute(uow, filters, pagination, sort)
    
    # Map to response
    return InvoiceMapper.to_paginated_response(page)
```

---

### 6. Database Considerations

#### 6.1 Index Support

The following indexes (from ADR-004) support efficient filtered pagination:

| Query Pattern | Index Used |
|--------------|------------|
| Invoices by student + status | `ix_invoices_student_status` (composite) |
| Invoices by due_date range | `ix_invoices_due_date` |
| Students by school | `ix_students_school_id` |
| Payments by invoice | `ix_payments_invoice_id` |

#### 6.2 Query Optimization

**Efficient query pattern:**
```sql
-- Get pending invoices for student, page 2
SELECT * FROM invoices
WHERE student_id = $1 AND status = 'pending'
ORDER BY created_at DESC, id DESC
LIMIT 20 OFFSET 20;

-- Count for pagination metadata
SELECT COUNT(*) FROM invoices
WHERE student_id = $1 AND status = 'pending';
```

**Performance notes:**
- Composite index `(student_id, status)` makes both queries efficient
- `COUNT(*)` on filtered results is fast with proper indexes
- Large offsets (>10,000) are prohibited by validation

#### 6.3 Avoiding N+1 Queries

When returning entities with relationships (e.g., invoice with student name), use eager loading:

```python
query = (
    select(InvoiceModel)
    .options(joinedload(InvoiceModel.student))  # Eager load student
    .where(...)
)
```

---

### 7. Error Handling

#### 7.1 Validation Errors (422)

```json
{
  "detail": [
    {
      "loc": ["query", "offset"],
      "msg": "ensure this value is less than or equal to 10000",
      "type": "value_error.number.not_le"
    }
  ]
}
```

#### 7.2 Invalid Enum Value (422)

```json
{
  "detail": [
    {
      "loc": ["query", "status"],
      "msg": "value is not a valid enumeration member; permitted: 'pending', 'partially_paid', 'paid', 'cancelled', 'overdue'",
      "type": "type_error.enum"
    }
  ]
}
```

#### 7.3 Invalid UUID (422)

```json
{
  "detail": [
    {
      "loc": ["query", "student_id"],
      "msg": "value is not a valid uuid",
      "type": "type_error.uuid"
    }
  ]
}
```

---

## Consequences

### Positive

- **Simplicity**: Offset-based pagination is easy to implement and understand
- **UI-friendly**: Supports "Page X of Y" and direct page jumping
- **Consistent response structure**: Same format across all list endpoints
- **Type safety**: Immutable dataclasses with validation
- **Clean Architecture**: Pagination logic stays in application/infrastructure layers
- **Testable**: Filter and pagination logic can be unit tested independently
- **Self-documenting**: OpenAPI schema includes all filter options

### Negative

- **Large offset performance**: Queries with offset > 1000 become slower (mitigated by 10,000 limit)
- **Count overhead**: `COUNT(*)` adds query overhead (acceptable for bounded datasets)
- **Result drift**: Data changes between page requests can cause skipped/duplicate items

### Trade-offs

- **Offset vs Cursor**: Chose offset for simplicity and UI compatibility; cursor can be added later if needed
- **Total count**: Included for UI convenience despite performance cost; can be made optional if needed

---

## Alternatives Considered

### 1. Cursor-Based Pagination

**Format:**
```
GET /api/v1/invoices?cursor=eyJpZCI6InV1aWQifQ==&limit=50
```

**Rejected because:**
- More complex to implement (cursor encoding/decoding)
- Cannot jump to arbitrary pages (poor UX for admin interfaces)
- Overkill for bounded school billing datasets

**When to reconsider:** If specific endpoints require real-time data consistency or infinite scroll with millions of records.

### 2. Page Number Instead of Offset

**Format:**
```
GET /api/v1/invoices?page=2&per_page=50
```

**Rejected because:**
- `offset` is more flexible and standard
- Client can calculate pages from offset/limit/total
- Avoids ambiguity about 0-based vs 1-based indexing

### 3. GraphQL-Style Connections

**Format:**
```graphql
{
  invoices(first: 10, after: "cursor") {
    edges { node { id } cursor }
    pageInfo { hasNextPage endCursor }
  }
}
```

**Rejected because:**
- Adds complexity without clear benefit for REST API
- Project uses REST, not GraphQL
- Unnecessary abstraction for simple use cases

### 4. Filter Object Syntax

**Format:**
```
GET /api/v1/invoices?filter[status]=pending&filter[student_id]=uuid
```

**Rejected because:**
- More complex to parse
- Less intuitive for simple filters
- Query parameters per field is clearer and sufficient

---

## Implementation Checklist

### Phase 1: Core Types
- [ ] Create `PaginationParams` dataclass in `application/common/`
- [ ] Create `SortParams` dataclass in `application/common/`
- [ ] Create `Page[T]` generic dataclass in `application/common/`
- [ ] Create filter dataclasses per entity (`InvoiceFilters`, etc.)
- [ ] Write unit tests for validation logic

### Phase 2: Repository Layer
- [ ] Add `find()` method to `InvoiceRepository` port
- [ ] Add `find()` method to `StudentRepository` port
- [ ] Add `find()` method to `PaymentRepository` port
- [ ] Add `find()` method to `SchoolRepository` port
- [ ] Implement `find()` in PostgreSQL repositories
- [ ] Write integration tests for filtered queries

### Phase 3: Use Cases
- [ ] Create `ListInvoicesUseCase`
- [ ] Create `ListStudentsUseCase`
- [ ] Create `ListPaymentsUseCase`
- [ ] Create `ListSchoolsUseCase`
- [ ] Write unit tests for use cases

### Phase 4: REST Layer
- [ ] Create `PaginationResponseDTO`
- [ ] Create `PaginatedInvoiceResponseDTO` (and others)
- [ ] Update invoice routes with pagination
- [ ] Update student routes with pagination
- [ ] Update payment routes with pagination
- [ ] Update school routes with pagination
- [ ] Add OpenAPI examples and descriptions

### Phase 5: Testing
- [ ] Write integration tests for paginated endpoints
- [ ] Test edge cases (empty results, single page, last page)
- [ ] Test invalid parameters (negative offset, limit > 200)
- [ ] Test filter combinations
- [ ] Verify indexes are used (`EXPLAIN ANALYZE`)

### Phase 6: Documentation
- [ ] Update README with pagination examples
- [ ] Add curl examples for common queries
- [ ] Document filter options per endpoint
- [ ] Update OpenAPI descriptions

---

## References

- [ADR-001: Project Initialization & Structure](ADR-001-project-initialization.md)
- [ADR-004: PostgreSQL Persistence with SQLAlchemy and Alembic](ADR-004-postgresql-persistence.md)
- [ADR-005: REST API Design](ADR-005-rest-api-design.md)
- [REST API Design: Filtering, Sorting, and Pagination](https://www.moesif.com/blog/technical/api-design/REST-API-Design-Filtering-Sorting-and-Pagination/)
- [Offset vs Cursor Pagination](https://slack.engineering/evolving-api-pagination-at-slack/)
- [FastAPI Query Parameters](https://fastapi.tiangolo.com/tutorial/query-params/)
