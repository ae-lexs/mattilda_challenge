# ADR-009: Repository Port and Adapter Implementation

## Status

Accepted

## Context

The mattilda_challenge system requires repository abstractions to access persisted entities (School, Student, Invoice, Payment). As established in previous ADRs:

- **[ADR-001](ADR-001-project-initialization.md)**: Clean Architecture requires ports (ABC interfaces) in the application layer and adapters (implementations) in the infrastructure layer
- **[ADR-004](ADR-004-postgresql-persistence.md)**: PostgreSQL persistence uses the Data Mapper pattern, session injection from UnitOfWork, flush-only semantics, and `for_update` parameter for row-level locking
- **[ADR-007](ADR-007-pagination.md)**: Pagination uses `find(filters, pagination, sort) -> Page[Entity]` method signature with entity-specific filter dataclasses

The UnitOfWork implementation (`infrastructure/postgres/unit_of_work.py`) already references repository adapters that do not yet exist:
- `PostgresSchoolRepository`
- `PostgresStudentRepository`
- `PostgresInvoiceRepository`
- `PostgresPaymentRepository`

This ADR defines:
1. Complete repository port interfaces (ABC classes)
2. PostgreSQL adapter implementation patterns
3. In-memory adapter implementations for testing
4. Error handling strategy

### Key Constraints (from existing ADRs)

| Decision | Source | Description |
|----------|--------|-------------|
| ABC interfaces | ADR-001 | Ports use `ABC` with `@abstractmethod`, not Protocol |
| Session injection | ADR-004 | Repositories receive `AsyncSession` from UnitOfWork |
| Flush-only | ADR-004 | Repositories call `flush()`, never `commit()` |
| `for_update` parameter | ADR-004 | `get_by_id()` supports row-level locking |
| Data Mapper pattern | ADR-004 | Static mapper classes convert Entity ↔ Model |
| Entity-specific filters | ADR-007 | `InvoiceFilters`, `StudentFilters`, etc. |
| `Page[T]` container | ADR-007 | Paginated results use generic `Page[T]` |
| `find()` method signature | ADR-007 | `find(filters, pagination, sort) -> Page[Entity]` |

---

## Decision

### 1. Repository Port Location

Repository ports are placed in `application/ports/` (not `domain/ports/`).

**Rationale**: While ADR-001 mentions `domain/ports/` in the project structure, placing repository interfaces in `application/ports/` is more consistent with Clean Architecture principles:
- Repositories are application-level concerns (data access orchestration)
- Domain layer should contain only pure business logic
- `TimeProvider` is already in `application/ports/`
- This keeps the domain layer completely free of persistence concepts

```
src/mattilda_challenge/
├── application/
│   └── ports/
│       ├── __init__.py
│       ├── time_provider.py          # Existing
│       ├── school_repository.py      # NEW
│       ├── student_repository.py     # NEW
│       ├── invoice_repository.py     # NEW
│       └── payment_repository.py     # NEW
└── infrastructure/
    └── adapters/
        ├── __init__.py
        ├── time_provider.py          # Existing
        ├── postgres_school_repository.py      # NEW
        ├── postgres_student_repository.py     # NEW
        ├── postgres_invoice_repository.py     # NEW
        └── postgres_payment_repository.py     # NEW
```

---

### 2. Repository Port Interfaces

Each repository port defines the complete contract for entity persistence operations.

#### 2.1 Base Method Signatures

All repositories share these core methods:

| Method | Signature | Description |
|--------|-----------|-------------|
| `get_by_id` | `async def get_by_id(id, for_update=False) -> Entity \| None` | Retrieve single entity with optional row lock |
| `save` | `async def save(entity) -> Entity` | Persist entity (insert or update) |
| `find` | `async def find(filters, pagination, sort) -> Page[Entity]` | Paginated filtered query |

#### 2.2 SchoolRepository Port

```python
# application/ports/school_repository.py
from __future__ import annotations

from abc import ABC, abstractmethod

from mattilda_challenge.application.common import Page, PaginationParams, SortParams
from mattilda_challenge.application.filters import SchoolFilters
from mattilda_challenge.domain.entities import School
from mattilda_challenge.domain.value_objects import SchoolId


class SchoolRepository(ABC):
    """
    Port for school data access.

    All implementations must inherit from this class and implement
    all abstract methods. Repositories never call commit() - that's
    owned by UnitOfWork.
    """

    @abstractmethod
    async def get_by_id(
        self,
        school_id: SchoolId,
        for_update: bool = False,
    ) -> School | None:
        """
        Get school by ID or None if not found.

        Args:
            school_id: Unique school identifier
            for_update: If True, acquire row lock (SELECT ... FOR UPDATE)

        Returns:
            School entity or None if not found
        """
        ...

    @abstractmethod
    async def save(self, school: School) -> School:
        """
        Save school entity to persistence.

        Performs upsert: inserts if new, updates if exists.
        Calls flush() to write to database within current transaction.

        Args:
            school: School entity to save

        Returns:
            Saved school (may have refreshed fields)
        """
        ...

    @abstractmethod
    async def find(
        self,
        filters: SchoolFilters,
        pagination: PaginationParams,
        sort: SortParams,
    ) -> Page[School]:
        """
        Find schools matching filters with pagination.

        Args:
            filters: Filter criteria (all optional)
            pagination: Offset and limit
            sort: Sort field and direction

        Returns:
            Page containing matching schools and metadata
        """
        ...
```

#### 2.3 StudentRepository Port

```python
# application/ports/student_repository.py
from __future__ import annotations

from abc import ABC, abstractmethod

from mattilda_challenge.application.common import Page, PaginationParams, SortParams
from mattilda_challenge.application.filters import StudentFilters
from mattilda_challenge.domain.entities import Student
from mattilda_challenge.domain.value_objects import SchoolId, StudentId


class StudentRepository(ABC):
    """
    Port for student data access.

    All implementations must inherit from this class and implement
    all abstract methods.
    """

    @abstractmethod
    async def get_by_id(
        self,
        student_id: StudentId,
        for_update: bool = False,
    ) -> Student | None:
        """
        Get student by ID or None if not found.

        Args:
            student_id: Unique student identifier
            for_update: If True, acquire row lock

        Returns:
            Student entity or None if not found
        """
        ...

    @abstractmethod
    async def save(self, student: Student) -> Student:
        """
        Save student entity to persistence.

        Args:
            student: Student entity to save

        Returns:
            Saved student
        """
        ...

    @abstractmethod
    async def find(
        self,
        filters: StudentFilters,
        pagination: PaginationParams,
        sort: SortParams,
    ) -> Page[Student]:
        """
        Find students matching filters with pagination.

        Args:
            filters: Filter criteria (school_id, status, email)
            pagination: Offset and limit
            sort: Sort field and direction

        Returns:
            Page containing matching students and metadata
        """
        ...

    @abstractmethod
    async def exists_by_email(self, email: str) -> bool:
        """
        Check if a student with given email already exists.

        Used for uniqueness validation before creating students.

        Args:
            email: Email address to check

        Returns:
            True if email is already in use
        """
        ...

    @abstractmethod
    async def count_by_school(self, school_id: SchoolId) -> int:
        """
        Count students in a school.

        Args:
            school_id: School to count students for

        Returns:
            Number of students in school
        """
        ...
```

#### 2.4 InvoiceRepository Port

```python
# application/ports/invoice_repository.py
from __future__ import annotations

from abc import ABC, abstractmethod
from decimal import Decimal

from mattilda_challenge.application.common import Page, PaginationParams, SortParams
from mattilda_challenge.application.filters import InvoiceFilters
from mattilda_challenge.domain.entities import Invoice
from mattilda_challenge.domain.value_objects import InvoiceId, StudentId


class InvoiceRepository(ABC):
    """
    Port for invoice data access.

    All implementations must inherit from this class and implement
    all abstract methods.
    """

    @abstractmethod
    async def get_by_id(
        self,
        invoice_id: InvoiceId,
        for_update: bool = False,
    ) -> Invoice | None:
        """
        Get invoice by ID or None if not found.

        IMPORTANT: Use for_update=True when recording payments to
        prevent concurrent modification race conditions.

        Args:
            invoice_id: Unique invoice identifier
            for_update: If True, acquire row lock (SELECT ... FOR UPDATE)

        Returns:
            Invoice entity or None if not found
        """
        ...

    @abstractmethod
    async def save(self, invoice: Invoice) -> Invoice:
        """
        Save invoice entity to persistence.

        Args:
            invoice: Invoice entity to save

        Returns:
            Saved invoice
        """
        ...

    @abstractmethod
    async def find(
        self,
        filters: InvoiceFilters,
        pagination: PaginationParams,
        sort: SortParams,
    ) -> Page[Invoice]:
        """
        Find invoices matching filters with pagination.

        Args:
            filters: Filter criteria (student_id, school_id, status, due_date range)
            pagination: Offset and limit
            sort: Sort field and direction

        Returns:
            Page containing matching invoices and metadata
        """
        ...

    @abstractmethod
    async def find_by_student(
        self,
        student_id: StudentId,
        pagination: PaginationParams,
        sort: SortParams,
    ) -> Page[Invoice]:
        """
        Find all invoices for a specific student.

        Convenience method for common query pattern.

        Args:
            student_id: Student to get invoices for
            pagination: Offset and limit
            sort: Sort field and direction

        Returns:
            Page containing student's invoices
        """
        ...

    @abstractmethod
    async def get_total_amount_by_student(self, student_id: StudentId) -> Decimal:
        """
        Get total invoiced amount for a student.

        Used for account statement calculations.

        Args:
            student_id: Student to calculate total for

        Returns:
            Sum of all invoice amounts (Decimal)
        """
        ...
```

#### 2.5 PaymentRepository Port

```python
# application/ports/payment_repository.py
from __future__ import annotations

from abc import ABC, abstractmethod
from decimal import Decimal

from mattilda_challenge.application.common import Page, PaginationParams, SortParams
from mattilda_challenge.application.filters import PaymentFilters
from mattilda_challenge.domain.entities import Payment
from mattilda_challenge.domain.value_objects import InvoiceId, PaymentId, StudentId


class PaymentRepository(ABC):
    """
    Port for payment data access.

    All implementations must inherit from this class and implement
    all abstract methods.
    """

    @abstractmethod
    async def get_by_id(
        self,
        payment_id: PaymentId,
        for_update: bool = False,
    ) -> Payment | None:
        """
        Get payment by ID or None if not found.

        Args:
            payment_id: Unique payment identifier
            for_update: If True, acquire row lock

        Returns:
            Payment entity or None if not found
        """
        ...

    @abstractmethod
    async def save(self, payment: Payment) -> Payment:
        """
        Save payment entity to persistence.

        Args:
            payment: Payment entity to save

        Returns:
            Saved payment
        """
        ...

    @abstractmethod
    async def find(
        self,
        filters: PaymentFilters,
        pagination: PaginationParams,
        sort: SortParams,
    ) -> Page[Payment]:
        """
        Find payments matching filters with pagination.

        Args:
            filters: Filter criteria (invoice_id, payment_date range)
            pagination: Offset and limit
            sort: Sort field and direction

        Returns:
            Page containing matching payments and metadata
        """
        ...

    @abstractmethod
    async def get_total_by_invoice(self, invoice_id: InvoiceId) -> Decimal:
        """
        Get total payments made against an invoice.

        CRITICAL for payment recording use case:
        - Determines remaining balance
        - Prevents overpayment

        Args:
            invoice_id: Invoice to sum payments for

        Returns:
            Sum of all payment amounts (Decimal), 0 if no payments
        """
        ...

    @abstractmethod
    async def get_total_by_student(self, student_id: StudentId) -> Decimal:
        """
        Get total payments made by a student (across all invoices).

        Used for account statement calculations.

        Args:
            student_id: Student to sum payments for

        Returns:
            Sum of all payment amounts (Decimal)
        """
        ...

    @abstractmethod
    async def find_by_invoice(
        self,
        invoice_id: InvoiceId,
        pagination: PaginationParams,
        sort: SortParams,
    ) -> Page[Payment]:
        """
        Find all payments for a specific invoice.

        Convenience method for common query pattern.

        Args:
            invoice_id: Invoice to get payments for
            pagination: Offset and limit
            sort: Sort field and direction

        Returns:
            Page containing invoice's payments
        """
        ...
```

---

### 3. PostgreSQL Adapter Implementation Pattern

All PostgreSQL adapters follow the same implementation pattern.

#### 3.1 Common Structure

```python
# infrastructure/adapters/postgres_invoice_repository.py
from __future__ import annotations

from decimal import Decimal

from sqlalchemy import func, select, and_
from sqlalchemy.ext.asyncio import AsyncSession

from mattilda_challenge.application.common import Page, PaginationParams, SortParams
from mattilda_challenge.application.filters import InvoiceFilters
from mattilda_challenge.application.ports import InvoiceRepository
from mattilda_challenge.domain.entities import Invoice
from mattilda_challenge.domain.value_objects import InvoiceId, StudentId
from mattilda_challenge.infrastructure.postgres.mappers import InvoiceMapper
from mattilda_challenge.infrastructure.postgres.models import InvoiceModel, StudentModel


class PostgresInvoiceRepository(InvoiceRepository):
    """
    PostgreSQL implementation of InvoiceRepository port.

    Uses SQLAlchemy async session injected from UnitOfWork.
    Never calls commit() - transaction management is UoW's responsibility.
    """

    def __init__(self, session: AsyncSession) -> None:
        """
        Initialize repository with database session.

        Args:
            session: SQLAlchemy async session (from UnitOfWork)
        """
        self._session = session

    async def get_by_id(
        self,
        invoice_id: InvoiceId,
        for_update: bool = False,
    ) -> Invoice | None:
        """Get invoice by ID with optional row lock."""
        stmt = select(InvoiceModel).where(InvoiceModel.id == invoice_id.value)

        if for_update:
            stmt = stmt.with_for_update()

        result = await self._session.execute(stmt)
        model = result.scalar_one_or_none()

        if model is None:
            return None

        return InvoiceMapper.to_entity(model)

    async def save(self, invoice: Invoice) -> Invoice:
        """
        Save invoice to database.

        Uses merge() for upsert behavior, then flush() to write
        to database within current transaction.
        """
        model = InvoiceMapper.to_model(invoice)
        merged = await self._session.merge(model)
        await self._session.flush()
        return InvoiceMapper.to_entity(merged)

    async def find(
        self,
        filters: InvoiceFilters,
        pagination: PaginationParams,
        sort: SortParams,
    ) -> Page[Invoice]:
        """Find invoices with filters, pagination, and sorting."""
        # Build base queries
        query = select(InvoiceModel)
        count_query = select(func.count()).select_from(InvoiceModel)

        # Apply filters
        conditions = self._build_conditions(filters)
        if conditions:
            query = query.where(and_(*conditions))
            count_query = count_query.where(and_(*conditions))

        # Apply sorting with deterministic secondary key
        sort_column = self._get_sort_column(sort.sort_by)
        if sort.sort_order == "desc":
            query = query.order_by(sort_column.desc(), InvoiceModel.id.desc())
        else:
            query = query.order_by(sort_column.asc(), InvoiceModel.id.asc())

        # Apply pagination
        query = query.offset(pagination.offset).limit(pagination.limit)

        # Execute queries
        result = await self._session.execute(query)
        models = result.scalars().all()

        total_result = await self._session.execute(count_query)
        total = total_result.scalar_one()

        # Map to domain entities
        items = tuple(InvoiceMapper.to_entity(m) for m in models)

        return Page(
            items=items,
            total=total,
            offset=pagination.offset,
            limit=pagination.limit,
        )

    async def find_by_student(
        self,
        student_id: StudentId,
        pagination: PaginationParams,
        sort: SortParams,
    ) -> Page[Invoice]:
        """Find all invoices for a student (convenience method)."""
        filters = InvoiceFilters(student_id=student_id.value)
        return await self.find(filters, pagination, sort)

    async def get_total_amount_by_student(self, student_id: StudentId) -> Decimal:
        """Get sum of all invoice amounts for a student."""
        stmt = (
            select(func.coalesce(func.sum(InvoiceModel.amount), Decimal("0")))
            .where(InvoiceModel.student_id == student_id.value)
        )
        result = await self._session.execute(stmt)
        return result.scalar_one()

    def _build_conditions(self, filters: InvoiceFilters) -> list:
        """Build SQLAlchemy filter conditions from InvoiceFilters."""
        conditions = []

        if filters.student_id is not None:
            conditions.append(InvoiceModel.student_id == filters.student_id)

        if filters.status is not None:
            conditions.append(InvoiceModel.status == filters.status)

        if filters.due_date_from is not None:
            conditions.append(InvoiceModel.due_date >= filters.due_date_from)

        if filters.due_date_to is not None:
            conditions.append(InvoiceModel.due_date <= filters.due_date_to)

        # school_id filter requires join through student relationship
        if filters.school_id is not None:
            conditions.append(
                InvoiceModel.student.has(StudentModel.school_id == filters.school_id)
            )

        return conditions

    def _get_sort_column(self, sort_by: str):
        """
        Map sort field name to SQLAlchemy column.
        
        NOTE: Validation of sort_by happens in the entrypoint layer (see ADR-007).
        This method provides a safe default if an invalid value reaches here,
        but this should never happen if the entrypoint validates correctly.
        """
        column_map = {
            "created_at": InvoiceModel.created_at,
            "due_date": InvoiceModel.due_date,
            "amount": InvoiceModel.amount,
            "status": InvoiceModel.status,
        }
        return column_map.get(sort_by, InvoiceModel.created_at)
```

#### 3.2 Key Implementation Rules

| Rule | Implementation | Rationale |
|------|----------------|-----------|
| **Session injection** | `__init__(self, session: AsyncSession)` | UoW manages session lifecycle |
| **Never commit** | Only call `flush()` | Transaction boundary owned by UoW |
| **Use merge for upsert** | `await self._session.merge(model)` | Handles both insert and update |
| **Row locking** | `stmt.with_for_update()` when `for_update=True` | Prevents concurrent modification |
| **Deterministic sorting** | Always include `id` as secondary sort key | Stable pagination across requests |
| **Map at boundary** | `InvoiceMapper.to_entity()` / `to_model()` | Domain never sees ORM models |

---

### 4. In-Memory Adapter for Testing

Each repository has an in-memory implementation for unit testing use cases without database dependencies.

#### 4.1 In-Memory Implementation Pattern

```python
# infrastructure/adapters/memory_invoice_repository.py
from __future__ import annotations

from decimal import Decimal

from mattilda_challenge.application.common import Page, PaginationParams, SortParams
from mattilda_challenge.application.filters import InvoiceFilters
from mattilda_challenge.application.ports import InvoiceRepository
from mattilda_challenge.domain.entities import Invoice
from mattilda_challenge.domain.value_objects import InvoiceId, StudentId


class InMemoryInvoiceRepository(InvoiceRepository):
    """
    In-memory implementation of InvoiceRepository for testing.

    Stores entities in a dictionary. Does not persist between test runs.
    Used in unit tests to verify use case behavior without database.
    """

    def __init__(self) -> None:
        """Initialize empty repository."""
        self._invoices: dict[InvoiceId, Invoice] = {}

    async def get_by_id(
        self,
        invoice_id: InvoiceId,
        for_update: bool = False,
    ) -> Invoice | None:
        """
        Get invoice by ID.

        Note: for_update is ignored in memory implementation
        (no concurrent access in unit tests).
        """
        return self._invoices.get(invoice_id)

    async def save(self, invoice: Invoice) -> Invoice:
        """Save invoice to in-memory storage."""
        self._invoices[invoice.id] = invoice
        return invoice

    async def find(
        self,
        filters: InvoiceFilters,
        pagination: PaginationParams,
        sort: SortParams,
    ) -> Page[Invoice]:
        """Find invoices with filtering, sorting, and pagination."""
        # Filter
        items = list(self._invoices.values())
        items = self._apply_filters(items, filters)

        # Sort
        items = self._apply_sort(items, sort)

        # Count before pagination
        total = len(items)

        # Paginate
        start = pagination.offset
        end = start + pagination.limit
        items = items[start:end]

        return Page(
            items=tuple(items),
            total=total,
            offset=pagination.offset,
            limit=pagination.limit,
        )

    async def find_by_student(
        self,
        student_id: StudentId,
        pagination: PaginationParams,
        sort: SortParams,
    ) -> Page[Invoice]:
        """Find all invoices for a student."""
        filters = InvoiceFilters(student_id=student_id.value)
        return await self.find(filters, pagination, sort)

    async def get_total_amount_by_student(self, student_id: StudentId) -> Decimal:
        """Get sum of all invoice amounts for a student."""
        total = Decimal("0")
        for invoice in self._invoices.values():
            if invoice.student_id == student_id:
                total += invoice.amount
        return total

    def _apply_filters(
        self,
        items: list[Invoice],
        filters: InvoiceFilters,
    ) -> list[Invoice]:
        """Apply filter criteria to invoice list."""
        result = items

        if filters.student_id is not None:
            result = [i for i in result if i.student_id.value == filters.student_id]

        if filters.status is not None:
            result = [i for i in result if i.status.value == filters.status]

        if filters.due_date_from is not None:
            result = [i for i in result if i.due_date >= filters.due_date_from]

        if filters.due_date_to is not None:
            result = [i for i in result if i.due_date <= filters.due_date_to]

        # LIMITATION: school_id filter requires access to StudentRepository.
        # In-memory repositories cannot perform cross-aggregate filtering.
        # For unit tests, either:
        # 1. Pre-filter test data to students from a single school
        # 2. Use integration tests for school_id filtering scenarios
        # See Section 4.3 for testing guidelines.

        return result

    def _apply_sort(
        self,
        items: list[Invoice],
        sort: SortParams,
    ) -> list[Invoice]:
        """Apply sorting to invoice list."""
        sort_key_map = {
            "created_at": lambda i: (i.created_at, i.id.value),
            "due_date": lambda i: (i.due_date, i.id.value),
            "amount": lambda i: (i.amount, i.id.value),
            "status": lambda i: (i.status.value, i.id.value),
        }

        key_func = sort_key_map.get(sort.sort_by, sort_key_map["created_at"])
        reverse = sort.sort_order == "desc"

        return sorted(items, key=key_func, reverse=reverse)

    # Test helper methods (not part of port interface)

    def clear(self) -> None:
        """Clear all stored invoices (test utility)."""
        self._invoices.clear()

    def add(self, invoice: Invoice) -> None:
        """Add invoice directly (test utility for setup)."""
        self._invoices[invoice.id] = invoice
```

#### 4.2 Testing Philosophy

| Test Type | Repository Used | Purpose |
|-----------|-----------------|---------|
| **Unit tests** | In-memory | Test use case logic in isolation |
| **Integration tests** | PostgreSQL | Test full persistence layer |
| **E2E tests** | PostgreSQL | Test complete request flow |

**Benefits of in-memory repositories:**
- Fast test execution (no I/O)
- No database setup required
- Deterministic behavior
- Easy test data setup via `add()` helper

**Limitations:**
- Cannot test database-specific behavior (transactions, locks, constraints)
- `school_id` filter on invoices requires additional setup
- Use integration tests for persistence-specific concerns

#### 4.3 Cross-Aggregate Filter Testing Guidelines

**INVARIANT**: Cross-aggregate filters (filters that span entity boundaries, such as `school_id` on invoices which requires joining through students) **must be tested via integration tests only**.

In-memory repositories cannot reliably simulate cross-aggregate queries because:
- They don't have access to related repositories
- Simulating joins would require coupling repositories together
- The behavior would differ from actual database queries

**Testing approach:**

| Filter Type | Unit Test (In-Memory) | Integration Test (PostgreSQL) |
|-------------|----------------------|------------------------------|
| Same-entity filters (`student_id`, `status`) | ✅ Test thoroughly | ✅ Verify query correctness |
| Cross-aggregate filters (`school_id` on invoices) | ❌ Skip or mock | ✅ **Required** |
| Date range filters | ✅ Test boundary conditions | ✅ Verify SQL behavior |

```python
# ✅ CORRECT: Unit test for same-entity filter
async def test_find_invoices_by_student_id(memory_invoice_repo):
    """Unit test - student_id is on Invoice entity."""
    invoice = create_test_invoice(student_id=StudentId(uuid4()))
    await memory_invoice_repo.save(invoice)
    
    page = await memory_invoice_repo.find(
        filters=InvoiceFilters(student_id=invoice.student_id.value),
        pagination=PaginationParams(offset=0, limit=10),
        sort=SortParams(sort_by="created_at", sort_order="desc"),
    )
    
    assert len(page.items) == 1

# ✅ CORRECT: Integration test for cross-aggregate filter
@pytest.mark.integration
async def test_find_invoices_by_school_id(postgres_session):
    """Integration test - school_id requires join through Student."""
    # Setup: create school, student, invoice in database
    # ...
    
    page = await repo.find(
        filters=InvoiceFilters(school_id=school.id.value),
        # ...
    )
    
    # Assert correct filtering through join

# ❌ WRONG: Unit test for cross-aggregate filter
async def test_find_invoices_by_school_id_unit(memory_invoice_repo):
    """Don't do this - in-memory can't simulate cross-aggregate joins."""
    # This test would give false confidence
```

---

### 5. Error Handling

#### 5.1 Repository Exception Policy

**INVARIANT**: Repositories must never raise domain-specific exceptions.

Repositories are infrastructure components and should not define or throw domain exceptions. Instead, they follow these rules:

| Scenario | Repository Behavior | Caller Responsibility |
|----------|--------------------|-----------------------|
| Entity not found | Return `None` | Use case raises `EntityNotFoundError` |
| Unique constraint violation | Let `IntegrityError` propagate | Entrypoint maps to HTTP 409 |
| Foreign key violation | Let `IntegrityError` propagate | Entrypoint maps to HTTP 400/404 |
| Connection error | Let `SQLAlchemyError` propagate | Global handler returns HTTP 503 |
| Invalid data from DB | Let mapping exception propagate | Indicates data corruption (critical) |

**Rationale:**
- Keeps repositories purely infrastructural (no domain knowledge)
- Domain exceptions are defined in the domain layer only
- Use cases decide when missing data is an error vs. expected
- Consistent with Clean Architecture boundaries

#### 5.2 Use Case Not-Found Handling

Use cases check for `None` and raise appropriate domain exceptions:

```python
# In use case
invoice = await self.invoice_repo.get_by_id(invoice_id, for_update=True)
if invoice is None:
    raise InvoiceNotFoundError(f"Invoice {invoice_id} not found")
```

#### 5.3 Database Constraint Violations

SQLAlchemy `IntegrityError` exceptions propagate to the use case or entrypoint layer, where they are mapped to appropriate domain or HTTP errors:

```python
# In entrypoint/error handler
from sqlalchemy.exc import IntegrityError

@app.exception_handler(IntegrityError)
async def handle_integrity_error(request, exc):
    if "unique constraint" in str(exc).lower():
        return JSONResponse(
            status_code=409,
            content={"detail": "Resource already exists"},
        )
    raise  # Re-raise unexpected integrity errors
```

---

### 6. Sort Validation Responsibility

**INVARIANT**: Validation of `sort_by` field happens in the entrypoint layer, not in repositories.

This is a critical architectural boundary that must not be violated:

| Layer | Responsibility |
|-------|---------------|
| **Entrypoint (routes)** | Validate `sort_by` against allowed fields, return 422 if invalid |
| **Use case** | Pass validated `SortParams` to repository |
| **Repository** | Trust that `sort_by` is valid, apply sorting |

**Why entrypoint validation:**
- Fast-fail with clear error message to client
- Keeps repositories simple (no validation logic)
- Consistent with other query parameter validation (offset, limit, filters)
- Allows different endpoints to allow different sort fields

**Implementation:**

```python
# ✅ CORRECT: Entrypoint validates sort_by
@router.get("/invoices")
async def list_invoices(
    sort_by: str = Query(
        default="created_at",
        description="Field to sort by",
        enum=["created_at", "due_date", "amount", "status"],  # Validation here
    ),
    sort_order: Literal["asc", "desc"] = Query(default="desc"),
    # ...
):
    # sort_by is guaranteed valid here
    sort = SortParams(sort_by=sort_by, sort_order=sort_order)
    # ...

# Repository trusts the value is valid
def _get_sort_column(self, sort_by: str):
    column_map = {
        "created_at": InvoiceModel.created_at,
        "due_date": InvoiceModel.due_date,
        "amount": InvoiceModel.amount,
        "status": InvoiceModel.status,
    }
    # Default fallback exists but should never be needed if entrypoint validates
    return column_map.get(sort_by, InvoiceModel.created_at)
```

See also: [ADR-007: Pagination Strategy](ADR-007-pagination.md), Section 4.4 Sort Validation.

---

### 7. Relationship Loading Strategy

#### 7.1 Eager Loading Policy

By default, repositories load entities **without** related entities. When relationships are needed, use explicit eager loading options.

```python
# Example: Load invoice with student (for display purposes)
async def get_by_id_with_student(
    self,
    invoice_id: InvoiceId,
) -> Invoice | None:
    stmt = (
        select(InvoiceModel)
        .options(joinedload(InvoiceModel.student))
        .where(InvoiceModel.id == invoice_id.value)
    )
    result = await self._session.execute(stmt)
    model = result.unique().scalar_one_or_none()

    if model is None:
        return None

    return InvoiceMapper.to_entity_with_student(model)
```

**Rationale:**
- Avoids N+1 query problems
- Makes data loading explicit
- Use cases request exactly what they need

#### 7.2 When to Load Relationships

| Scenario | Strategy | Rationale |
|----------|----------|-----------|
| Single entity lookup | Lazy (default) | Usually only need the entity |
| List for display | Eager load needed fields | Avoid N+1 queries |
| Account statement | Aggregate queries | Don't load entities at all |
| Payment recording | Invoice only + row lock | Minimal data for business logic |

---

## Consequences

### Positive

- **Testability**: In-memory repositories enable fast unit tests without database
- **Clean separation**: Ports define contracts, adapters implement them
- **Consistency**: All repositories follow the same pattern
- **Type safety**: ABC with `@abstractmethod` catches missing implementations at runtime
- **Flexibility**: Can add new implementations (e.g., MongoDB) without changing ports

### Negative

- **Boilerplate**: Each repository requires port interface + PostgreSQL adapter + in-memory adapter
- **Duplication**: Filter/sort logic duplicated between PostgreSQL and in-memory implementations
- **Learning curve**: Team must understand port/adapter pattern

### Trade-offs

- **Explicit over implicit**: More files but clearer architecture
- **Testing flexibility over DRY**: Some duplication enables isolated testing

---

## Implementation Checklist

### Phase 1: Port Interfaces
- [ ] Create `SchoolRepository` ABC in `application/ports/`
- [ ] Create `StudentRepository` ABC in `application/ports/`
- [ ] Create `InvoiceRepository` ABC in `application/ports/`
- [ ] Create `PaymentRepository` ABC in `application/ports/`
- [ ] Update `application/ports/__init__.py` exports

### Phase 2: Filter Types
- [ ] Create `SchoolFilters` dataclass in `application/filters/`
- [ ] Create `StudentFilters` dataclass in `application/filters/`
- [ ] Create `InvoiceFilters` dataclass in `application/filters/`
- [ ] Create `PaymentFilters` dataclass in `application/filters/`

### Phase 3: PostgreSQL Adapters
- [ ] Implement `PostgresSchoolRepository`
- [ ] Implement `PostgresStudentRepository`
- [ ] Implement `PostgresInvoiceRepository`
- [ ] Implement `PostgresPaymentRepository`
- [ ] Update `infrastructure/adapters/__init__.py` exports

### Phase 4: In-Memory Adapters
- [ ] Implement `InMemorySchoolRepository`
- [ ] Implement `InMemoryStudentRepository`
- [ ] Implement `InMemoryInvoiceRepository`
- [ ] Implement `InMemoryPaymentRepository`

### Phase 5: Testing
- [ ] Write unit tests for PostgreSQL adapters (integration tests)
- [ ] Write unit tests for in-memory adapters
- [ ] Write integration tests for cross-aggregate filters
- [ ] Verify UnitOfWork works with implemented repositories
- [ ] Test row locking behavior with concurrent requests

### Phase 6: Documentation
- [ ] Update CONTRIBUTING.md with repository invariants
- [ ] Add cross-aggregate testing guidelines to testing docs

---

## References

- [ADR-001: Project Initialization & Structure](ADR-001-project-initialization.md)
- [ADR-004: PostgreSQL Persistence with SQLAlchemy and Alembic](ADR-004-postgresql-persistence.md)
- [ADR-007: Pagination Strategy](ADR-007-pagination.md)
- [Cosmic Python - Repository Pattern](https://www.cosmicpython.com/book/chapter_02_repository.html)
- [Cosmic Python - Unit of Work](https://www.cosmicpython.com/book/chapter_06_uow.html)
