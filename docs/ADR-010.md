# ADR-010: UseCase Pattern and Error Handling Strategy

## Status

Implemented

## Context

With the domain model (ADR-002), time provider (ADR-003), repository ports (ADR-009), and persistence layer (ADR-004) in place, we need to define how **application use cases** orchestrate these components.

Use cases represent the **application layer** in Clean Architecture—they coordinate domain logic and infrastructure without containing business rules themselves. A well-defined use case pattern ensures:

- Consistency across all application operations
- Clear separation between orchestration and business logic
- Testability without infrastructure dependencies
- Explicit transaction boundaries for financial operations
- Predictable error handling across the system

### Key Questions

1. **Dependency Injection**: How do use cases receive their dependencies (repositories, time)?
2. **Transaction Coordination**: Who owns commit/rollback for multi-repository operations?
3. **Input/Output**: How are requests and responses structured?
4. **Error Handling**: How do domain errors propagate to the entrypoints layer?

### Constraints from Existing ADRs

| ADR | Constraint |
|-----|------------|
| ADR-001 | Ports use ABC (Abstract Base Classes), not Protocols |
| ADR-002 | Domain entities are immutable; business logic lives in entities/value objects |
| ADR-003 | Time is always injected, never accessed directly |
| ADR-004 | Repositories never commit; Unit of Work owns transaction lifecycle |
| ADR-009 | Repositories return `None` for not-found; use cases raise domain exceptions |

## Decision

### 1. UnitOfWork Port (Application Layer Abstraction)

The `UnitOfWork` is abstracted as an **ABC port** in the application layer. This keeps use cases infrastructure-agnostic while providing explicit transaction control.

```python
# application/ports/unit_of_work.py
from __future__ import annotations

from abc import ABC, abstractmethod
from types import TracebackType

from mattilda_challenge.application.ports import (
    InvoiceRepository,
    PaymentRepository,
    SchoolRepository,
    StudentRepository,
)


class UnitOfWork(ABC):
    """
    Port for transactional operations across repositories.

    Contract:
    - All repository properties share the same transaction context
    - commit() persists all changes atomically
    - rollback() discards all changes
    - Auto-rollback on exception when used as context manager

    Usage:
        async with uow:
            await uow.invoices.save(invoice)
            await uow.payments.save(payment)
            await uow.commit()  # Atomic
    """

    @property
    @abstractmethod
    def schools(self) -> SchoolRepository:
        """School repository within this transaction."""
        ...

    @property
    @abstractmethod
    def students(self) -> StudentRepository:
        """Student repository within this transaction."""
        ...

    @property
    @abstractmethod
    def invoices(self) -> InvoiceRepository:
        """Invoice repository within this transaction."""
        ...

    @property
    @abstractmethod
    def payments(self) -> PaymentRepository:
        """Payment repository within this transaction."""
        ...

    @abstractmethod
    async def commit(self) -> None:
        """Commit all changes atomically."""
        ...

    @abstractmethod
    async def rollback(self) -> None:
        """Rollback all changes."""
        ...

    @abstractmethod
    async def __aenter__(self) -> UnitOfWork:
        """Enter transaction context."""
        ...

    @abstractmethod
    async def __aexit__(
        self,
        exc_type: type[BaseException] | None,
        exc_val: BaseException | None,
        exc_tb: TracebackType | None,
    ) -> None:
        """Exit with auto-rollback on exception."""
        ...
```

**Rationale**:
- Use cases depend on the **port** (ABC), not the infrastructure implementation
- Transaction coordination happens where business logic lives (use case layer)
- Testable with `InMemoryUnitOfWork` that uses in-memory repositories
- Consistent with existing repository port pattern (ADR-009)

### 2. UseCase Structure: Class-Based with Single Responsibility

Each use case is a **dedicated class** with a single `execute()` method:

```python
# application/use_cases/record_payment.py
from __future__ import annotations

from datetime import datetime

from mattilda_challenge.application.ports import UnitOfWork
from mattilda_challenge.application.use_cases.requests import RecordPaymentRequest
from mattilda_challenge.domain.entities import Payment
from mattilda_challenge.domain.exceptions import (
    CannotPayCancelledInvoiceError,
    InvoiceNotFoundError,
    PaymentExceedsBalanceError,
)
from mattilda_challenge.domain.value_objects import InvoiceStatus


class RecordPaymentUseCase:
    """
    Use case: Record a payment against an invoice.

    Business rules enforced:
    - Invoice must exist
    - Invoice cannot be cancelled
    - Payment cannot exceed remaining balance
    - Invoice status updated atomically with payment creation

    Transaction boundary:
    - Payment creation + invoice status update in single atomic commit
    - Row locking prevents concurrent payment race conditions
    """

    async def execute(
        self,
        uow: UnitOfWork,
        request: RecordPaymentRequest,
        now: datetime,
    ) -> Payment:
        """
        Record payment and update invoice status.

        Args:
            uow: Unit of Work for transactional access
            request: Payment details (immutable request DTO)
            now: Current timestamp (injected, never call datetime.now())

        Returns:
            Created Payment entity

        Raises:
            InvoiceNotFoundError: Invoice doesn't exist
            CannotPayCancelledInvoiceError: Invoice is cancelled
            PaymentExceedsBalanceError: Amount exceeds balance due
        """
        async with uow:
            # 1. Fetch invoice with row lock (prevents race conditions)
            invoice = await uow.invoices.get_by_id(
                request.invoice_id,
                for_update=True
            )
            if invoice is None:
                raise InvoiceNotFoundError(
                    f"Invoice {request.invoice_id} not found"
                )

            # 2. Validate business rules
            if invoice.status == InvoiceStatus.CANCELLED:
                raise CannotPayCancelledInvoiceError(
                    f"Cannot record payment for cancelled invoice {invoice.id}"
                )

            # 3. Calculate balance due
            # IMPORTANT: This query MUST execute within the same transaction
            # as the row lock above. The for_update=True on get_by_id ensures
            # the invoice row is locked, but get_total_by_invoice reads the
            # payments table. The adapter implementation MUST use the same
            # database session/transaction to prevent race conditions where
            # a concurrent payment is inserted between these two queries.
            total_paid = await uow.payments.get_total_by_invoice(invoice.id)
            balance_due = invoice.amount - total_paid

            if request.amount > balance_due:
                raise PaymentExceedsBalanceError(
                    f"Payment {request.amount} exceeds balance due {balance_due}"
                )

            # 4. Create payment (domain entity handles validation)
            payment = Payment.create(
                invoice_id=invoice.id,
                amount=request.amount,
                payment_date=request.payment_date,
                payment_method=request.payment_method,
                reference_number=request.reference_number,
                now=now,
            )

            # 5. Determine new invoice status
            new_balance = balance_due - request.amount
            if new_balance == Decimal("0"):
                new_status = InvoiceStatus.PAID
            else:
                new_status = InvoiceStatus.PARTIALLY_PAID

            # 6. Update invoice status (immutable - returns new instance)
            updated_invoice = invoice.update_status(new_status, now)

            # 7. Persist changes
            await uow.payments.save(payment)
            await uow.invoices.save(updated_invoice)

            # 8. Atomic commit
            await uow.commit()

            return payment
```

**Key characteristics**:
- **Single responsibility**: One use case = one business operation
- **No constructor dependencies**: UoW passed to `execute()`, enabling flexibility
- **Explicit transaction**: `async with uow` + `await uow.commit()`
- **Domain exceptions**: Raised for business rule violations (not HTTP errors)

### 3. Time Injection: Parameter to execute()

Time is passed as a parameter to `execute()`, **not** injected via constructor:

```python
async def execute(
    self,
    uow: UnitOfWork,
    request: CreateInvoiceRequest,
    now: datetime,  # Always injected, never datetime.now()
) -> Invoice:
```

**Rationale**:
- Consistent with ADR-003 (time injection pattern)
- Route handler fetches time once from `TimeProvider` and passes to use case
- All domain operations within a use case receive the **same `now`** value
- Deterministic testing without mocking

**Usage in route handler**:
```python
@router.post("/invoices")
async def create_invoice(
    request: InvoiceCreateRequestDTO,
    uow: UnitOfWork = Depends(get_unit_of_work),
    time_provider: TimeProvider = Depends(get_time_provider),
) -> InvoiceResponseDTO:
    now = time_provider.now()  # Fetch once

    domain_request = InvoiceMapper.to_create_request(request)
    use_case = CreateInvoiceUseCase()
    invoice = await use_case.execute(uow, domain_request, now)

    return InvoiceMapper.to_response(invoice, now)
```

### 4. Request DTOs: Immutable Application Layer Objects

Each use case has a dedicated **Request dataclass** in the application layer:

```python
# application/use_cases/requests.py
from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime
from decimal import Decimal

from mattilda_challenge.domain.value_objects import (
    InvoiceId,
    LateFeePolicy,
    StudentId,
)


@dataclass(frozen=True, slots=True)
class CreateInvoiceRequest:
    """Request to create a new invoice."""

    student_id: StudentId
    amount: Decimal
    due_date: datetime
    description: str
    late_fee_policy: LateFeePolicy


@dataclass(frozen=True, slots=True)
class RecordPaymentRequest:
    """Request to record a payment."""

    invoice_id: InvoiceId
    amount: Decimal
    payment_date: datetime
    payment_method: str
    reference_number: str | None = None


@dataclass(frozen=True, slots=True)
class CancelInvoiceRequest:
    """Request to cancel an invoice."""

    invoice_id: InvoiceId
    cancellation_reason: str
```

**Characteristics**:
- **Frozen dataclasses**: Immutable, consistent with domain pattern
- **Domain value objects**: Use `StudentId`, `InvoiceId`, `Decimal` (not raw types)
- **No `now` field**: Time passed separately to `execute()`
- **Validation at construction**: Invalid requests fail fast

**Conversion responsibility**:
- **Entrypoint mappers** convert HTTP DTOs → Request DTOs (str → Decimal, str → UUID, etc.)
- Use cases receive already-validated domain types

### 5. Response Pattern: Domain Entities

Use cases return **domain entities** directly:

```python
async def execute(...) -> Invoice:
    # ...
    return saved_invoice
```

**Rationale**:
- Domain entities are immutable and safe to return
- Entrypoint mappers convert entities → HTTP response DTOs
- No duplication of entity structure in "response DTOs"

**Exception**: For complex aggregations (account statements), use dedicated **application DTOs**:

```python
# application/dtos/account_statement.py
@dataclass(frozen=True, slots=True)
class StudentAccountStatement:
    """Aggregated financial summary for a student."""

    student_id: StudentId
    student_name: str
    school_name: str
    total_invoiced: Decimal
    total_paid: Decimal
    total_pending: Decimal
    invoices_pending: int
    invoices_partially_paid: int
    invoices_paid: int
    invoices_cancelled: int
    invoices_overdue: int
    total_late_fees: Decimal
    statement_date: datetime
```

### 6. Error Handling: Domain Exceptions Propagate

Use cases raise **domain exceptions** (defined in `domain/exceptions.py`). The entrypoints layer catches and maps to HTTP status codes.

**Critical principle: UseCases do NOT catch exceptions**

UseCases should **never** wrap code in try/except blocks, except in the rare case where additional context must be added to an exception before re-raising. This ensures:

- Domain exceptions propagate cleanly to global handlers
- No accidental swallowing of errors
- Consistent error handling across all use cases
- Clear separation: use cases orchestrate, entrypoints handle HTTP concerns

```python
# ✅ Correct: Let exceptions propagate naturally
async def execute(self, uow: UnitOfWork, request: Request, now: datetime) -> Entity:
    async with uow:
        entity = await uow.entities.get_by_id(request.id)
        if entity is None:
            raise EntityNotFoundError(...)  # Propagates to global handler
        
        # Domain operations may raise - let them propagate
        result = entity.do_something(now)
        await uow.entities.save(result)
        await uow.commit()
        return result

# ❌ Wrong: Catching exceptions internally
async def execute(self, uow: UnitOfWork, request: Request, now: datetime) -> Entity:
    try:
        async with uow:
            entity = await uow.entities.get_by_id(request.id)
            # ... operations ...
    except SomeDomainError:
        # Don't do this - defeats global handler pattern
        return None  # or raise different exception
```

**Only exception** - enriching context before re-raising:

```python
# ✅ Acceptable: Adding context then re-raising
async def execute(self, uow: UnitOfWork, request: Request, now: datetime) -> Entity:
    async with uow:
        try:
            result = await some_complex_operation(...)
        except DomainError as e:
            # Add context, then re-raise same exception type
            raise type(e)(f"Failed during {request.operation_name}: {e}") from e
```

**Use case raises domain errors**:
```python
# In use case
if invoice is None:
    raise InvoiceNotFoundError(f"Invoice {invoice_id} not found")

if invoice.status == InvoiceStatus.CANCELLED:
    raise CannotPayCancelledInvoiceError(...)
```

**Global handlers in entrypoints**:
```python
# entrypoints/http/app.py
from mattilda_challenge.domain.exceptions import (
    DomainError,
    InvoiceNotFoundError,
    StudentNotFoundError,
    PaymentExceedsBalanceError,
    InvalidStateTransitionError,
)

# 404 - Not Found
@app.exception_handler(InvoiceNotFoundError)
@app.exception_handler(StudentNotFoundError)
@app.exception_handler(SchoolNotFoundError)
@app.exception_handler(PaymentNotFoundError)
async def handle_not_found(request: Request, exc: DomainError) -> JSONResponse:
    return JSONResponse(status_code=404, content={"detail": str(exc)})

# 400 - Business Rule Violation
@app.exception_handler(CannotPayCancelledInvoiceError)
@app.exception_handler(InvalidStateTransitionError)
@app.exception_handler(PaymentExceedsBalanceError)
async def handle_business_rule_violation(request: Request, exc: DomainError) -> JSONResponse:
    return JSONResponse(status_code=400, content={"detail": str(exc)})

# 422 - Validation Error (input format issues)
@app.exception_handler(InvalidInvoiceAmountError)
@app.exception_handler(InvalidPaymentAmountError)
@app.exception_handler(InvalidTimestampError)
async def handle_validation_error(request: Request, exc: DomainError) -> JSONResponse:
    return JSONResponse(status_code=422, content={"detail": str(exc)})
```

**Exception to HTTP mapping**:

| Exception Category | HTTP Status | Example |
|-------------------|-------------|---------|
| `*NotFoundError` | 404 | `InvoiceNotFoundError`, `StudentNotFoundError` |
| Business rule violations | 400 | `PaymentExceedsBalanceError`, `InvalidStateTransitionError` |
| Input validation | 422 | `InvalidInvoiceAmountError`, `InvalidTimestampError` |
| Unexpected errors | 500 | Uncaught exceptions (bugs) |

**Route handlers do NOT catch exceptions**:
```python
# ✅ Correct: Let exceptions propagate
@router.post("/payments")
async def record_payment(...) -> PaymentResponseDTO:
    use_case = RecordPaymentUseCase()
    payment = await use_case.execute(uow, request, now)
    # Exceptions propagate to global handlers
    return PaymentMapper.to_response(payment)

# ❌ Wrong: Catching in route
@router.post("/payments")
async def record_payment(...):
    try:
        payment = await use_case.execute(...)
    except PaymentExceedsBalanceError as e:  # Duplicates global handler
        raise HTTPException(status_code=400, detail=str(e))
```

### 7. File Organization

```
src/mattilda_challenge/
├── application/
│   ├── ports/
│   │   ├── __init__.py
│   │   ├── unit_of_work.py          # NEW: UnitOfWork ABC
│   │   ├── school_repository.py
│   │   ├── student_repository.py
│   │   ├── invoice_repository.py
│   │   ├── payment_repository.py
│   │   └── time_provider.py
│   ├── use_cases/
│   │   ├── __init__.py
│   │   ├── requests.py              # All request DTOs
│   │   ├── create_school.py
│   │   ├── update_school.py
│   │   ├── delete_school.py
│   │   ├── create_student.py
│   │   ├── update_student.py
│   │   ├── delete_student.py
│   │   ├── create_invoice.py
│   │   ├── cancel_invoice.py
│   │   ├── record_payment.py
│   │   ├── get_student_account_statement.py
│   │   └── get_school_account_statement.py
│   ├── dtos/
│   │   └── account_statement.py     # Complex aggregation DTOs
│   ├── common.py
│   └── filters.py
├── infrastructure/
│   └── postgres/
│       └── unit_of_work.py          # PostgresUnitOfWork implements ABC
```

### 8. Complete UseCase Example

```python
# application/use_cases/create_invoice.py
from __future__ import annotations

from datetime import datetime

from mattilda_challenge.application.ports import UnitOfWork
from mattilda_challenge.application.use_cases.requests import CreateInvoiceRequest
from mattilda_challenge.domain.entities import Invoice
from mattilda_challenge.domain.exceptions import StudentNotFoundError


class CreateInvoiceUseCase:
    """
    Use case: Create a new invoice for a student.

    Validates:
    - Student exists
    - Student belongs to an active school

    Domain entity handles:
    - Amount validation (positive Decimal)
    - Due date validation (UTC, after created_at)
    - Late fee policy validation
    """

    async def execute(
        self,
        uow: UnitOfWork,
        request: CreateInvoiceRequest,
        now: datetime,
    ) -> Invoice:
        """
        Create invoice for student.

        Args:
            uow: Unit of Work for transactional access
            request: Invoice creation details
            now: Current timestamp

        Returns:
            Created Invoice entity

        Raises:
            StudentNotFoundError: Student doesn't exist
        """
        async with uow:
            # 1. Validate student exists
            student = await uow.students.get_by_id(request.student_id)
            if student is None:
                raise StudentNotFoundError(
                    f"Student {request.student_id} not found"
                )

            # 2. Create invoice (domain entity validates business rules)
            invoice = Invoice.create(
                student_id=request.student_id,
                amount=request.amount,
                due_date=request.due_date,
                description=request.description,
                late_fee_policy=request.late_fee_policy,
                now=now,
            )

            # 3. Persist
            saved = await uow.invoices.save(invoice)

            # 4. Commit
            await uow.commit()

            return saved
```

### 9. Testing Strategy

**Unit tests** use `InMemoryUnitOfWork`:

```python
# tests/unit/application/use_cases/test_create_invoice.py
import pytest
from datetime import datetime, UTC
from decimal import Decimal

from mattilda_challenge.application.use_cases import CreateInvoiceUseCase
from mattilda_challenge.application.use_cases.requests import CreateInvoiceRequest
from mattilda_challenge.domain.exceptions import StudentNotFoundError
from tests.helpers import InMemoryUnitOfWork, create_test_student


@pytest.fixture
def uow() -> InMemoryUnitOfWork:
    return InMemoryUnitOfWork()


@pytest.fixture
def fixed_time() -> datetime:
    return datetime(2024, 1, 1, 12, 0, 0, tzinfo=UTC)


async def test_create_invoice_success(uow: InMemoryUnitOfWork, fixed_time: datetime):
    """Invoice created successfully for existing student."""
    # Arrange
    student = create_test_student()
    await uow.students.save(student)

    request = CreateInvoiceRequest(
        student_id=student.id,
        amount=Decimal("1500.00"),
        due_date=datetime(2024, 2, 1, tzinfo=UTC),
        description="January tuition",
        late_fee_policy=LateFeePolicy.standard(),
    )

    # Act
    use_case = CreateInvoiceUseCase()
    invoice = await use_case.execute(uow, request, fixed_time)

    # Assert
    assert invoice.student_id == student.id
    assert invoice.amount == Decimal("1500.00")
    assert invoice.status == InvoiceStatus.PENDING
    assert uow.committed is True


async def test_create_invoice_student_not_found(uow: InMemoryUnitOfWork, fixed_time: datetime):
    """Raises StudentNotFoundError when student doesn't exist."""
    request = CreateInvoiceRequest(
        student_id=StudentId.generate(),  # Non-existent
        amount=Decimal("1500.00"),
        due_date=datetime(2024, 2, 1, tzinfo=UTC),
        description="January tuition",
        late_fee_policy=LateFeePolicy.standard(),
    )

    use_case = CreateInvoiceUseCase()

    with pytest.raises(StudentNotFoundError) as exc_info:
        await use_case.execute(uow, request, fixed_time)

    assert "not found" in str(exc_info.value)
    assert uow.committed is False
```

## Consequences

### Positive

- **Pure Clean Architecture**: Use cases depend only on ports (ABCs), fully testable without infrastructure
- **Explicit transaction boundaries**: `async with uow` + `commit()` makes atomicity visible
- **Consistent error handling**: Domain exceptions map predictably to HTTP status codes
- **Immutable requests**: Request DTOs are frozen dataclasses, preventing mutation bugs
- **Time consistency**: Single `now` value passed through entire operation
- **Single responsibility**: One class per business operation, easy to understand and modify
- **Composable use cases**: This pattern enables future composition of use cases without breaking invariants—a use case can delegate to another use case, passing the same `uow` and `now`, ensuring the entire operation remains atomic and time-consistent

### Trade-offs

- **More types**: Request DTOs add classes to maintain (mitigated by shared `requests.py` file)
- **Explicit UoW in signature**: Every use case receives `uow` parameter (provides clarity at cost of verbosity)
- **No constructor injection**: Dependencies passed to `execute()` rather than `__init__()` (enables stateless use cases)

### Negative

- **Infrastructure must implement UoW ABC**: Existing `PostgresUnitOfWork` needs to implement the new port interface (one-time migration)

## Implementation Checklist

- [ ] Create `application/ports/unit_of_work.py` (UnitOfWork ABC)
- [ ] Update `infrastructure/postgres/unit_of_work.py` to implement ABC
- [ ] Create `application/use_cases/requests.py` (all request DTOs)
- [ ] Create `tests/helpers/in_memory_unit_of_work.py` for testing
- [ ] Implement use cases following this pattern
- [ ] Add global exception handlers in `entrypoints/http/app.py`
- [x] Update CONTRIBUTING.md with UseCase guidelines reference

## Related ADRs

- [ADR-001](ADR-001.md): Project Initialization & Structure (ABC ports requirement)
- [ADR-002](ADR-002.md): Domain Model Design (entity immutability, business logic placement)
- [ADR-003](ADR-003.md): Time Provider Interface (time injection pattern)
- [ADR-004](ADR-004.md): PostgreSQL Persistence (repository pattern, transaction handling)
- [ADR-009](ADR-009.md): Repository Port and Adapter Implementation (repository contracts)
