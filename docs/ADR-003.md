# ADR-003: Time Provider Interface and Implementation

## Status

Accepted

## Context

Time is a critical factor in billing operations, specifically for late fee calculation. The `calculate_late_fee(now)` method in the Invoice entity requires reliable time comparisons to determine if an invoice is overdue and calculate the appropriate fee.

**Operational Scope**: The mattilda_challenge system operates as a single-process application in a local development environment (Docker Compose with uvicorn). This operational scope defines the time consistency requirements: application time provides sufficient correctness guarantees for all billing operations within a single process.

We need a time abstraction that:

- Enables deterministic testing of time-based scenarios (e.g., "1 day before due date", "exactly at due date", "30 days overdue")
- Isolates the domain from infrastructure concerns (domain doesn't call `datetime.now()` directly)
- Prevents timezone-related bugs (all times in UTC)
- Allows testing boundary conditions (what happens exactly at midnight on the due date?)

Given the single-process execution model, application-level time is the appropriate source of truth for this system.

### Why Time Abstraction Matters

Without a time provider, testing late fee scenarios becomes problematic:

```python
# ❌ Without TimeProvider - not testable
class Invoice:
    def calculate_late_fee(self) -> Decimal:
        now = datetime.now(UTC)  # Cannot control in tests!
        if now <= self.due_date:
            return Decimal("0.00")
        # ...

# Test is non-deterministic
def test_late_fee():
    invoice = create_invoice(due_date=???)  # What date ensures overdue?
    fee = invoice.calculate_late_fee()      # Result depends on when test runs!
    assert fee == ???                       # Cannot predict
```

With time injection, tests become deterministic:

```python
# ✅ With TimeProvider - fully testable
class Invoice:
    def calculate_late_fee(self, now: datetime) -> Decimal:
        if now <= self.due_date:
            return Decimal("0.00")
        # ...

# Test is deterministic
def test_late_fee_one_day_overdue():
    invoice = create_invoice(due_date=datetime(2024, 1, 1, tzinfo=UTC))
    time_provider.set_time(datetime(2024, 1, 2, tzinfo=UTC))  # Exactly 1 day after
    
    fee = invoice.calculate_late_fee(time_provider.now())
    assert fee == Decimal("2.50")  # Predictable result
```

## Decision

### 1. Port in Application Layer

The `TimeProvider` interface (port) lives in the **application layer**. Implementations live in the **infrastructure layer**.

```
src/mattilda_challenge/
├── application/
│   └── ports/
│       └── time_provider.py    # Abstract interface
└── infrastructure/
    └── time_provider.py        # SystemTimeProvider, FixedTimeProvider
```

This follows Clean Architecture: the application layer defines what it needs, infrastructure provides it.

### 2. Interface Definition

We use **ABC** (Abstract Base Class) for explicit interface enforcement (as required by ADR-001).

```python
from abc import ABC, abstractmethod
from datetime import UTC, datetime


class TimeProvider(ABC):
    """Port for time operations.

    Contract:
    - now() MUST return a datetime with tzinfo=datetime.UTC
    - now() MUST NOT return naive datetimes under any circumstance
    - Not just "timezone-aware"—specifically UTC (no -06:00 offsets)

    Naive datetime = bug. This is non-negotiable.
    """

    @abstractmethod
    def now(self) -> datetime:
        """Return the current UTC datetime (tzinfo=datetime.UTC)."""
```

**Note**: We use `datetime.UTC` (available in Python 3.11+) as the canonical UTC constant throughout the codebase.

### 3. Production Implementation

For production, we use **application server time** via `datetime.now(UTC)`.

```python
from datetime import UTC, datetime


class SystemTimeProvider(TimeProvider):
    """Production time provider using system clock."""

    def now(self) -> datetime:
        return datetime.now(UTC)
```

**Rationale**: Given the single-process operational model, application time serves as the authoritative time source for all billing operations. Each process maintains its own consistent view of time throughout transaction execution.

### 4. UTC Only Policy

**All internal timestamps are UTC.** The domain layer exclusively works with UTC-aware datetimes.

Timezone conversion happens **only at API boundaries**:

```
[Client Request]              [Domain]                    [Client Response]
     │                           │                              │
     ▼                           ▼                              ▼
 "2024-01-01T12:00:00-06:00" → datetime(UTC)  → "2024-01-01T18:00:00Z"
 (client local time)           (always UTC)     (ISO 8601 UTC)
```

The entrypoints layer (FastAPI controllers) is responsible for:
- Parsing incoming timestamps and converting to UTC
- Formatting outgoing timestamps as ISO 8601 with `Z` suffix

The domain **never** handles timezone conversion or naive datetimes.

### 5. Test Implementation

`FixedTimeProvider` returns a fixed timestamp that can be explicitly changed via `set_time()`.

```python
from datetime import UTC, datetime


class FixedTimeProvider(TimeProvider):
    """Test time provider with controllable fixed timestamp.
    
    Usage:
        time_provider = FixedTimeProvider(datetime(2024, 1, 1, tzinfo=UTC))
        time_provider.set_time(datetime(2024, 1, 15, tzinfo=UTC))  # Simulate 15 days later
    """

    def __init__(self, fixed_time: datetime) -> None:
        self._validate_utc(fixed_time)
        self._fixed_time = fixed_time

    def now(self) -> datetime:
        return self._fixed_time

    def set_time(self, new_time: datetime) -> None:
        """Explicitly change the fixed time for testing scenarios."""
        self._validate_utc(new_time)
        self._fixed_time = new_time

    def _validate_utc(self, dt: datetime) -> None:
        if dt.tzinfo is not UTC:
            raise ValueError(
                f"datetime must have tzinfo=UTC, got tzinfo={dt.tzinfo}"
            )
```

This implementation enables explicit control over time progression in tests, making time-based business logic fully deterministic and verifiable.

### 6. UTC Validation in Infrastructure

`FixedTimeProvider` validates that input datetimes have `tzinfo=UTC` specifically—not just any timezone-aware value. This is **contract enforcement**, not domain logic.

- The `TimeProvider` interface promises `tzinfo=datetime.UTC`
- The test implementation ensures test authors don't accidentally pass `-06:00` or other offsets
- Validation happens at test setup time, catching bugs early

The domain trusts that `TimeProvider.now()` always returns `tzinfo=UTC` datetimes and does not re-validate.

### 7. Overdue Comparison Rule

Per ADR-002, an invoice is overdue if `now > due_date`. The comparison uses strict greater-than:

| Condition | Result |
|-----------|--------|
| `now <= due_date` | Not overdue (no late fee) |
| `now > due_date` | Overdue (late fee applies) |

This means a late fee calculation at exactly the due date time returns **zero**.

### 8. Usage in Domain Methods

The domain method receives `now` as an injected parameter:

```python
class Invoice:
    def calculate_late_fee(self, now: datetime) -> Decimal:
        """
        Calculate late fee using policy.
        
        Args:
            now: Current timestamp (injected by use case)
        
        Returns:
            Late fee amount, rounded to cents
        """
        if not self.is_overdue(now):
            return Decimal("0.00")
        
        return self.late_fee_policy.calculate_fee(
            original_amount=self.amount,
            due_date=self.due_date,
            now=now,
        )
    
    def is_overdue(self, now: datetime) -> bool:
        """Check if invoice is overdue."""
        return now > self.due_date
```

The use case fetches `now` **once** and passes it to domain methods:

```python
class CalculateLateFeeUseCase:
    def __init__(self, time_provider: TimeProvider) -> None:
        self._time_provider = time_provider

    def execute(self, invoice: Invoice) -> Decimal:
        now = self._time_provider.now()  # Single fetch
        return invoice.calculate_late_fee(now)  # Pass to domain
```

This ensures time consistency within a single operation.

### 9. Testing Time-Based Scenarios

Use `FixedTimeProvider` with explicit `set_time()` calls:

```python
from datetime import UTC, datetime
import pytest


def test_no_late_fee_before_due_date(time_provider: FixedTimeProvider):
    """Late fee is zero when invoice is not yet due."""
    invoice = create_invoice(
        amount=Decimal("1500.00"),
        due_date=datetime(2024, 1, 15, tzinfo=UTC),
        late_fee_rate=Decimal("0.05"),  # 5% monthly
    )
    
    # Set time to 1 day before due date
    time_provider.set_time(datetime(2024, 1, 14, tzinfo=UTC))
    
    fee = invoice.calculate_late_fee(time_provider.now())
    assert fee == Decimal("0.00")


def test_no_late_fee_exactly_at_due_date(time_provider: FixedTimeProvider):
    """Late fee is zero when now equals due_date (boundary condition)."""
    invoice = create_invoice(
        amount=Decimal("1500.00"),
        due_date=datetime(2024, 1, 15, 12, 0, 0, tzinfo=UTC),  # Noon
        late_fee_rate=Decimal("0.05"),
    )
    
    # Set time to exactly the due date
    time_provider.set_time(datetime(2024, 1, 15, 12, 0, 0, tzinfo=UTC))
    
    fee = invoice.calculate_late_fee(time_provider.now())
    assert fee == Decimal("0.00")  # now <= due_date → no fee


def test_late_fee_one_day_overdue(time_provider: FixedTimeProvider):
    """Late fee applies 1 day after due date."""
    invoice = create_invoice(
        amount=Decimal("1500.00"),
        due_date=datetime(2024, 1, 15, tzinfo=UTC),
        late_fee_rate=Decimal("0.05"),  # 5% monthly = $75/month = $2.50/day
    )
    
    # Set time to 1 day after due date
    time_provider.set_time(datetime(2024, 1, 16, tzinfo=UTC))
    
    fee = invoice.calculate_late_fee(time_provider.now())
    
    # Monthly fee: 1500 × 0.05 = 75.00
    # Daily fee: 75.00 / 30 = 2.50
    # 1 day × 2.50 = 2.50
    assert fee == Decimal("2.50")


def test_late_fee_30_days_overdue(time_provider: FixedTimeProvider):
    """Late fee accumulates over 30 days."""
    invoice = create_invoice(
        amount=Decimal("1500.00"),
        due_date=datetime(2024, 1, 1, tzinfo=UTC),
        late_fee_rate=Decimal("0.05"),
    )
    
    # Set time to 30 days after due date
    time_provider.set_time(datetime(2024, 1, 31, tzinfo=UTC))
    
    fee = invoice.calculate_late_fee(time_provider.now())
    
    # Monthly fee: 1500 × 0.05 = 75.00
    # 30 days × 2.50/day = 75.00
    assert fee == Decimal("75.00")
```

## Consequences

### Positive

- **Testable**: Time-based scenarios are deterministic and explicit
- **Clean Architecture**: Port in application, implementation in infrastructure
- **Safe**: UTC validation catches configuration errors at instantiation time
- **Explicit control**: `set_time()` makes time changes visible and intentional in tests
- **Realistic testing**: Tests can simulate exact business scenarios (due dates, grace periods, boundary conditions)
- **Appropriate complexity**: Design matches operational scope (single-process execution)

### Trade-offs

- **Explicit injection**: Domain methods require `now` parameter, making time dependency visible in method signatures
- **Manual time control**: Tests must explicitly set time for each scenario (provides clarity at the cost of verbosity)

### Design Decisions

- **Application time as source of truth**: Chosen for single-process operational model
- **UTC enforcement**: Prevents timezone-related bugs by rejecting non-UTC datetimes at construction
- **Immutable test provider**: `set_time()` replaces the current time rather than advancing it, making each test scenario explicit

## Related ADRs

- [ADR-001](ADR-001-project-initialization.md): Project Initialization & Structure (ABC ports requirement)
- [ADR-002](ADR-002.md): Domain Model Design (late fee calculation, `is_overdue()` logic)

## Future Work

### Scope Expansion Scenarios

If the system's operational scope expands beyond single-process execution, the time strategy may be re-evaluated:

- **Multi-process deployments**: If the system is deployed with multiple application processes, consider whether cross-process time consistency is required for business correctness
- **External time sources**: If the system integrates with external services that require shared time references (e.g., payment gateways with time-based windows), a database-backed time provider may be introduced
- **Distributed operations**: If billing operations span multiple systems or services, a centralized time source may be needed to ensure consistency

Each expansion would be addressed through a new ADR evaluating the specific requirements and trade-offs.

### Alternative Test Patterns

- **Auto-advancing time**: If integration tests require simulating time progression without explicit `set_time()` calls, consider implementing `AdvancingTimeProvider`
- **Freeze time decorator**: If many tests share the same time setup, consider pytest fixtures or decorators to reduce verbosity
